{
  "examples": [
    {
      "input": "async function fetchNews() { const response = await fetch('https://newsapi.org/v1/latest-news'); return await response.json(); } test('should fetch latest news', async () => { const news = await fetchNews(); expect(news.articles.length).toBe(10); });",
      "output": "Add Mock: Mocking the news API ensures the test is not affected by external server response times or availability."
    },
    {
      "input": "let dbConnection; async function connectToDatabase() { dbConnection = await db.connect(); return dbConnection; } test('should connect to database', async () => { const connection = await connectToDatabase(); expect(connection).toBeDefined(); });",
      "output": "Manage Resource: Ensure the database connection is properly closed after each test to prevent resource leaks."
    },
    {
      "input": "async function loadProfile() { const profile = await fetch('/api/profile'); return await profile.json(); } test('should load profile within timeout', async () => { const profile = await loadProfile(); expect(profile).toBeDefined(); });",
      "output": "Handle Timeout: Using promise-timeout to set a time limit on profile load."
    },
    {
      "input": "async function fetchOrderHistory(userId) { const response = await fetch(`/api/users/${userId}/orders`); return await response.json(); } test('should fetch order history for user', async () => { const orders = await fetchOrderHistory(123); expect(orders.length).toBe(2); });",
      "output": "Add Mock: Order history APIs may return varying results depending on the time and server load. Mocking the API ensures the test passes consistently."
    },
    {
      "input": "let sidebarOpen = false; async function toggleSidebar() { sidebarOpen = !sidebarOpen; return sidebarOpen; } test('should toggle sidebar', async () => { const state = await toggleSidebar(); expect(state).toBe(true); });",
      "output": "Isolate State: The sidebar state persists across tests. Resetting the state before each test prevents interference between tests."
    },
    {
      "input": "test('should display updated investment portfolio after changes', async () => { updatePortfolio(); expect(document.querySelector('.portfolio-update').textContent).toBe('Portfolio Updated'); });",
      "output": "Add/Adjust Wait: Investment portfolios may take time to update due to asynchronous data fetching. Adding a wait ensures the updated portfolio is displayed before assertions."
    },
    {
      "input": "let globalCounter = 0; async function incrementGlobalCounter() { globalCounter++; } test('should increment global counter', async () => { await incrementGlobalCounter(); expect(globalCounter).toBe(1); });",
      "output": "Isolate State: The global counter can cause flakiness if shared between tests. Using an isolated counter state ensures reliable tests."
    },
    {
      "input": "let systemConfig = { timeout: 3000 }; async function updateSystemTimeout(newTimeout) { systemConfig.timeout = newTimeout; } test('should update system timeout', async () => { await updateSystemTimeout(5000); expect(systemConfig.timeout).toBe(5000); });",
      "output": "Isolate State: Using worker threads to isolate system configuration between tests."
    },
    {
      "input": "test('should disable fields after form submission', async () => { submitForm(); expect(document.querySelectorAll('input').forEach(input => input.disabled)).toBe(true); });",
      "output": "Add/Adjust Wait: Form fields are disabled asynchronously after submission, so waiting is necessary."
    },
    {
      "input": "test('should calculate loan interest in 500ms', async () => { const start = Date.now(); await calculateLoanInterest(); const end = Date.now(); expect(end - start).toBeLessThan(500); });",
      "output": "Widen Assertion: Loan interest calculation time may vary depending on data size or server load. Widening the assertion window ensures tests do not fail due to minor delays."
    },
    {
      "input": "test('should update warehouse inventory after receiving shipment', async () => { await receiveShipment('shipment789'); const inventory = getWarehouseInventory(); expect(inventory.items.length).toBeGreaterThan(0); });",
      "output": "Isolate State: Warehouse inventory state may persist across tests, leading to interference. Resetting the inventory ensures independent test execution."
    },
    {
      "input": "async function connectToGameEventStream() { const socket = new WebSocket('wss://events.example.com'); return socket; } test('should connect to game event stream WebSocket', async () => { const socket = await connectToGameEventStream(); expect(socket.readyState).toBe(1); });",
      "output": "Manage Resource: Game event WebSocket streams should be closed after the test to prevent resource leaks. Adding a `finally` block ensures that the WebSocket is closed properly."
    },
    {
      "input": "async function connectToMultiplayer(playerId) { return new Promise(resolve => setTimeout(() => resolve('Connected'), 3500)); } test('should connect player to multiplayer', async () => { const result = await connectToMultiplayer(101); expect(result).toBe('Connected'); });",
      "output": "Add/Adjust Wait: Multiplayer connection can take time due to server load. Adjust the wait time for stability."
    },
    {
      "input": "let store = createStore(rootReducer); async function addUser(user) { store.dispatch({ type: 'ADD_USER', user }); } test('should add a new user', async () => { await addUser({ name: 'Alice' }); expect(store.getState().users.length).toBe(1); });",
      "output": "Isolate State: Global state in Redux can lead to test flakiness. Isolating the Redux store for each test ensures independent state and avoids data leakage between tests."
    },
    {
      "input": "async function fetchOrderHistory(api) { return await api.getHistory(); } test('should fetch order history', async () => { const api = new OrderService(); const history = await fetchOrderHistory(api); expect(history.length).toBe(3); });",
      "output": "Add Mock: Using in-memory cache to mock order history fetching."
    },
    {
      "input": "let shoppingCart = { items: [] }; async function addToCart(item) { shoppingCart.items.push(item); } test('should add item to cart', async () => { await addToCart({ name: 'TV' }); expect(shoppingCart.items.length).toBe(1); });",
      "output": "Isolate State: Using dependency injection to provide isolated shopping cart."
    },
    {
      "input": "test('should return notifications with correct message', async () => { const notifications = await getNotifications(); expect(notifications[0].message).toBe('New message'); });",
      "output": "Widen Assertion: Using jest-extended to assert partial notification object matching."
    },
    {
      "input": "test('should process user input and update multiple services', async () => { const userInput = await getUserInput(); const processedData = await processInput(userInput); const service1Response = await updateService1(processedData); const service2Response = await updateService2(processedData); expect(service1Response && service2Response).toBeTruthy(); }, 300);",
      "output": "Handle Timeout: In this test, multiple async operations are chained together to process user input and update multiple services. The 300ms timeout might not be sufficient for all services to respond within that timeframe, leading to flakiness. Extending the timeout allows more time for all services to complete their operations."
    },
    {
      "input": "async function getCartItems(service) { const cart = await service.getCart(); return cart; } test('should fetch cart items', async () => { const service = new CartService(); const cart = await getCartItems(service); expect(cart.items.length).toBe(2); });",
      "output": "Add Mock: Injecting a mock service and using spies to monitor the `getCart` method."
    },
    {
      "input": "test('should process user input and update profile asynchronously', async () => { let userInput = await getUserInput(); let profileData = await updateProfile(userInput); expect(profileData).toBeDefined(); });",
      "output": "Handle Timeout: In this test, the async operations of fetching user input and updating the profile might occasionally take longer due to network latency or server load. By extending the timeout, we allow sufficient time for these operations to complete without prematurely failing the test."
    },
    {
      "input": "async function fetchStockPrice(symbol) { const response = await fetch(`/api/stocks/${symbol}/price`); return await response.json(); } test('should fetch stock price for symbol', async () => { const price = await fetchStockPrice('AAPL'); expect(price).toBe(150); });",
      "output": "Add Mock: Stock prices change frequently, making it hard to maintain test consistency. Mocking the API provides stable results."
    },
    {
      "input": "async function openDatabaseConnection() { const db = { connected: true }; return db; } test('should open and close database connection', async () => { const db = await openDatabaseConnection(); expect(db.connected).toBe(true); });",
      "output": "Manage Resource: Using graceful-fs for efficient resource management."
    },
    {
      "input": "async function resetPlayerStats(playerId) { return new Promise(resolve => setTimeout(() => resolve('Stats Reset'), 3000)); } test('should reset player stats', async () => { const result = await resetPlayerStats(101); expect(result).toBe('Stats Reset'); });",
      "output": "Add/Adjust Wait: Resetting player stats may take longer than expected. Adjust the wait time to handle potential delays."
    },
    {
      "input": "async function getCartTotal(cartService) { return await cartService.calculateTotal(); } test('should calculate cart total', async () => { const cartService = new CartService(); const total = await getCartTotal(cartService); expect(total).toBeDefined(); });",
      "output": "Add Mock: Using jest.doMock() to dynamically mock calculateTotal."
    },
    {
      "input": "test('should show search results after submitting query', async () => { submitSearchQuery('laptop'); expect(document.querySelectorAll('.result-item').length).toBe(5); });",
      "output": "Add/Adjust Wait: Search results are fetched asynchronously. Adding a wait ensures that all results are loaded before asserting the number of items."
    },
    {
      "input": "async function loadPlayerInventory(playerId) { return new Promise(resolve => setTimeout(() => resolve(['sword', 'shield']), 5000)); } test('should load player inventory', async () => { const inventory = await loadPlayerInventory(101); expect(inventory.length).toBeGreaterThan(0); });",
      "output": "Handle Timeout: Loading large inventories may take longer. Increase the test timeout to accommodate for the delay."
    },
    {
      "input": "test('should disable submit button after invalid input', async () => { inputInvalidData(); expect(document.querySelector('#submit-button').disabled).toBe(true); });",
      "output": "Add/Adjust Wait: Validation and UI updates happen asynchronously. The test checks the button state too early. Adding a wait ensures the validation completes."
    },
    {
      "input": "async function getOrderHistory(orderService) { return await orderService.fetchHistory(); } test('should fetch order history', async () => { const orderService = new OrderService(); const history = await getOrderHistory(orderService); expect(history).toBeDefined(); });",
      "output": "Add Mock: Using jest.spyOn to mock orderService.fetchHistory method."
    },
    {
      "input": "test('should return complete blog post details', async () => { const post = await getBlogPost(); expect(post).toEqual({ title: 'Async/Await Guide', author: 'John', content: 'Lorem ipsum dolor sit amet...' }); });",
      "output": "Widen Assertion: Using partial deep match to verify only the `title` and `author` fields of the blog post."
    },
    {
      "input": "async function processUserData() { const userData = await getUserData(); const processedData = await processUser(userData); return processedData; } test('should process user data', async () => { const result = await processUserData(); expect(result.valid).toBe(true); });",
      "output": "Add/Adjust Wait: This test involves multiple async operations where data processing depends on fetching user data and subsequent processing. Introducing appropriate waits between these operations ensures that each step completes before proceeding, preventing race conditions and flakiness."
    },
    {
      "input": "test('should show download completion after file download', async () => { downloadFile(); expect(document.querySelector('.status').textContent).toBe('Download Complete'); });",
      "output": "Add/Adjust Wait: File downloads are asynchronous, and the status message updates only after the download completes. Adding a wait ensures the message is rendered before making the assertion."
    },
    {
      "input": "test('should display shopping cart summary after items are added', async () => { addToCart(); expect(document.querySelector('#cart-summary').textContent).toBe('$100'); });",
      "output": "Add/Adjust Wait: Using requestIdleCallback to wait for cart summary to update."
    },
    {
      "input": "test('should process multiple file uploads and cleanup resources', async () => { let uploadedFiles = []; try { const file1 = await uploadFile('file1.txt'); uploadedFiles.push(file1); const file2 = await uploadFile('file2.txt'); uploadedFiles.push(file2); expect(uploadedFiles.length).toBe(2); } finally { uploadedFiles.forEach(async (file) => { await cleanupResource(file); }); } });",
      "output": "Handle Timeout: Flaky tests involving resource cleanup like file uploads and cleanup operations may fail due to timing issues in releasing resources. Extending the timeout allows sufficient time for all operations to complete, ensuring proper cleanup and avoiding premature failures."
    },
    {
      "input": "test('should load product images when scrolled into view', async () => { loadProductImages(); expect(document.querySelector('#product-img').src).toBe('phone.jpg'); });",
      "output": "Add/Adjust Wait: Using IntersectionObserver to wait for product images visibility."
    },
    {
      "input": "async function fetchUserSession(userId) { const session = await cacheService.get(`session:${userId}`); return session; } test('should return cached session data', async () => { const session = await fetchUserSession(101); expect(session).toBeDefined(); });",
      "output": "Add Mock: Cache systems may return different results due to invalidation or expiration. Mocking the cache response ensures the test remains stable and reliable."
    },
    {
      "input": "test('should show confirmation message when button is clicked', async () => { clickButton(); expect(document.querySelector('#confirmation').style.visibility).toBe('visible'); });",
      "output": "Add/Adjust Wait: Using requestAnimationFrame to wait for confirmation message visibility."
    },
    {
      "input": "test('should return transaction summary', async () => { const transaction = await getTransactionSummary(); expect(transaction).toEqual({ id: 789, status: 'Completed', amount: 150 }); });",
      "output": "Widen Assertion: Using lodash.isMatch for flexible transaction summary comparison."
    },
    {
      "input": "let redisClient; async function connectToRedis() { redisClient = await redis.connect(); return redisClient; } test('should connect to Redis', async () => { const connection = await connectToRedis(); expect(connection).toBeDefined(); });",
      "output": "Manage Resource: Ensure Redis connections are closed properly after each test to avoid resource leaks."
    },
    {
      "input": "async function getDeliveryRoute(routeId) { const response = await fetch(`https://api.logistics.com/routes/${routeId}`); return await response.json(); } test('should fetch delivery route for route 305', async () => { const route = await getDeliveryRoute(305); expect(route.steps.length).toBeGreaterThan(0); });",
      "output": "Add Mock: Delivery route data is fetched from external services which can introduce flakiness. Mocking the API ensures consistent test behavior."
    },
    {
      "input": "async function uploadProductImage(imageFile) { const response = await uploadToServer(imageFile); return response; } test('should upload image for product review', async () => { const response = await uploadProductImage('image.jpg'); expect(response.success).toBe(true); });",
      "output": "Manage Resource: Image uploads can consume memory and disk space, leading to leaks if not properly managed. Cleaning up after the upload prevents resource exhaustion."
    },
    {
      "input": "let dbConnection = openDbConnection(); async function getUsers() { return await dbConnection.query('SELECT * FROM users'); } test('should fetch users', async () => { const users = await getUsers(); expect(users.length).toBeGreaterThan(0); });",
      "output": "Isolate State: Reinitializing the database connection to ensure isolated test execution."
    },
    {
      "input": "test('should process data from WebSocket stream', async () => { const data = await fetchDataFromStream(); expect(data).toEqual({ id: 1, name: 'Alice' }); });",
      "output": "Add Mock: This test relies on data from a WebSocket stream, which introduces flakiness due to network latency or stream variations. By mocking the WebSocket stream with predefined data, the test can run consistently without external dependencies."
    },
    {
      "input": "test('should sync user data within 4 seconds', async () => { const result = await syncUserData(); expect(result.success).toBe(true); });",
      "output": "Handle Timeout: Syncing data may take longer due to server load. Increasing the timeout improves test reliability."
    },
    {
      "input": "async function getOrderStatus(orderId) { const response = await fetch(`/api/order/${orderId}`); return await response.json(); } test('should fetch order status within timeout', async () => { const status = await getOrderStatus(123); expect(status).toBeDefined(); });",
      "output": "Handle Timeout: Using Promise.race() to handle async timeout."
    },
    {
      "input": "let messageQueue; async function connectToMessageQueue() { messageQueue = await MessageQueue.connect(); return messageQueue; } test('should connect to message queue', async () => { const queue = await connectToMessageQueue(); expect(queue).toBeDefined(); });",
      "output": "Manage Resource: Ensure message queue connections are closed after each test to prevent keeping open, unused connections."
    },
    {
      "input": "async function checkOrderStatus(orderId) { setTimeout(() => orderId.status = 'shipped', 4000); return orderId; } test('should check order status', async () => { const order = await checkOrderStatus({ id: 101, status: 'processing' }); expect(order.status).toBe('shipped'); });",
      "output": "Add/Adjust Wait: Shipping updates may take time to reflect. Increase the wait time to ensure the status is updated."
    },
    {
      "input": "test('should open and close database connection for transaction history', async () => { const db = await connectToDatabase(); await db.fetchTransactionHistory(); });",
      "output": "Manage Resource: Database connections should be closed after use to avoid overloading the connection pool."
    },
    {
      "input": "async function craftWeapon(playerId, weaponId) { return new Promise(resolve => setTimeout(() => resolve('Weapon Crafted'), 4000)); } test('should craft weapon', async () => { const result = await craftWeapon(101, 'sword123'); expect(result).toBe('Weapon Crafted'); });",
      "output": "Add/Adjust Wait: Crafting weapons might take longer due to server-side processes. Add wait time to ensure test stability."
    },
    {
      "input": "test('should analyze user demographics within 3 seconds', async () => { const demographics = await analyzeUserDemographics(); expect(demographics.success).toBe(true); }, 3000);",
      "output": "Handle Timeout: Analyzing user demographics may take longer, especially for large user bases. Extending the timeout ensures the analysis completes successfully."
    },
    {
      "input": "test('should reset environment variables before build', async () => { triggerBuild(); const envVars = await fetchEnvironmentVariables(); expect(envVars.length).toBe(0); });",
      "output": "Isolate State: Environment variables from previous tests can persist and affect builds. Resetting them ensures clean test execution."
    },
    {
      "input": "test('should close cloud storage after backup operation', async () => { const cloudStorage = await connectToCloudStorage(); await backupData(cloudStorage); expect(cloudStorage.isClosed()).toBe(true); });",
      "output": "Manage Resource: Cloud storage connections left open can exhaust resources. Ensuring the connection is closed after each test prevents leaks."
    },
    {
      "input": "test('should fetch user data within 2 seconds', async () => { const user = await fetchUserData(); expect(user).toBeDefined(); });",
      "output": "Handle Timeout: Implementing retries with exponential backoff to handle potential network timeouts when fetching user data."
    },
    {
      "input": "test('should fetch exactly 15 blog posts', async () => { const posts = await fetchBlogPosts(); expect(posts.length).toBe(15); });",
      "output": "Widen Assertion: The number of blog posts may fluctuate depending on the database state. Widening the assertion allows flexibility and prevents flakiness due to small variations."
    },
    {
      "input": "let activeSessions = {}; async function startSession(userId) { activeSessions[userId] = { active: true }; return activeSessions; } test('should start session', async () => { const result = await startSession(1); expect(result[1].active).toBe(true); });",
      "output": "Isolate State: Session data persists between tests. Reset the activeSessions state to ensure isolation."
    },
    {
      "input": "test('should disable edit button after form submission', async () => { submitForm(); expect(document.querySelector('#edit').disabled).toBe(true); });",
      "output": "Add/Adjust Wait: Disabling the edit button happens asynchronously. Adding a wait ensures proper assertion timing."
    },
    {
      "input": "async function createShipment(orderId) { return new Promise(resolve => setTimeout(() => resolve('Shipment created'), 4000)); } test('should create shipment', async () => { const shipment = await createShipment(123); expect(shipment).toBe('Shipment created'); });",
      "output": "Handle Timeout: Shipment creation can be delayed depending on the carrier API response times. Extend the timeout."
    },
    {
      "input": "async function fetchProjectTasks(projectId) { const response = await fetch(`https://api.project.com/${projectId}/tasks`); return await response.json(); } test('should retrieve project tasks', async () => { const tasks = await fetchProjectTasks(456); expect(tasks.length).toBe(3); });",
      "output": "Add Mock: Mock the project management API to avoid relying on live task data."
    },
    {
      "input": "async function getCachedSettings() { const settings = await cacheService.get('app-settings'); return settings; } test('should return cached app settings', async () => { const settings = await getCachedSettings(); expect(settings.theme).toBe('dark'); });",
      "output": "Add Mock: App settings in cache may vary or become stale. Mocking the cache response ensures consistent data across test runs."
    },
    {
      "input": "test('should reset cart before adding item', async () => { addItemToCart('item1'); const cart = await getCart(); expect(cart.items.length).toBe(1); });",
      "output": "Isolate State: Previous tests may leave items in the cart, causing interference. Resetting the cart ensures the test starts with a clean state."
    },
    {
      "input": "test('should disable submit button after validating form', async () => { validateForm(); expect(document.querySelector('.submit-btn').disabled).toBe(true); });",
      "output": "Add/Adjust Wait: Form validation happens asynchronously, and the UI might not update immediately. Adding a wait ensures that the form is validated before asserting."
    },
    {
      "input": "test('should display backup progress after initiating cloud backup', async () => { initiateBackup('instance-123'); expect(document.querySelector('#backup-progress').textContent).toBe('50%'); });",
      "output": "Add/Adjust Wait: Cloud backups can take time depending on the size of the data. Adding a wait ensures the progress is updated before making assertions."
    },
    {
      "input": "test('should release GPU resources after rendering graphics', async () => { const gpu = await allocateGpuResources(); await renderGraphics(gpu, 'scene-001'); expect(gpu.isReleased()).toBe(true); });",
      "output": "Manage Resource: GPU resources should be released after rendering to avoid excessive memory and power usage. Releasing ensures efficient management of GPU resources."
    },
    {
      "input": "async function syncCustomerData() { const data1 = await getCustomerProfile(); const processedCustomerProfile = process(data1); const data2 = await fetchPaymentHistory(); const processedPaymentHistory = process(data2); return mergeData(processedCustomerProfile, processedPaymentHistory); } test('should return merged and processed data', async () => { const accountSyncResult = await syncCustomerData(); expect(accountSyncResult).toEqual(updatedAccountDetails); });",
      "output": "Add Mock: The test relies on multiple asynchronous operations that fetch data from different sources sequentially, making it prone to flakiness due to variations in network speed or source availability. By adding mocks for fetchDataFromSource1 and fetchDataFromSource2, we can control the data retrieval process, ensuring consistent and predictable test outcomes."
    },
    {
      "input": "test('should return exactly 3 recent transactions', async () => { const transactions = await getRecentTransactions(); expect(transactions.length).toBe(3); });",
      "output": "Widen Assertion: Recent transactions may vary, causing test failures. Widening the assertion ensures stability in changing data."
    },
    {
      "input": "async function connectToCloudService() { const service = await cloudService.connect(); return service; } test('should connect to cloud service', async () => { const service = await connectToCloudService(); expect(service).toBeTruthy(); });",
      "output": "Manage Resource: Cloud service connections should be properly closed after use to avoid resource leaks. Ensuring the service is closed after the test prevents resource exhaustion."
    },
    {
      "input": "async function checkInventory() { const inventoryService = openInventoryService(); inventoryService.on('update', u => console.log('Update:', u)); return new Promise(resolve => { inventoryService.on('disconnect', resolve); }); } test('should check inventory and clean up listeners', async () => { const result = await checkInventory(); expect(result).toBeDefined(); });",
      "output": "Manage Resource: Using event listeners to clean up inventory service connections."
    },
    {
      "input": "let gameSession = { powerUpsUsed: 0 }; async function usePowerUp() { gameSession.powerUpsUsed += 1; } test('should use a power-up in the game session', async () => { await usePowerUp(); expect(gameSession.powerUpsUsed).toBe(1); });",
      "output": "Isolate State: Power-up usage shared between tests can lead to flakiness. Isolating the session ensures each test manages power-up usage independently."
    },
    {
      "input": "test('should authenticate user with Google login in 3 seconds', async () => { const user = await authenticateWithGoogle(); expect(user).toBeDefined(); });",
      "output": "Handle Timeout: Authenticating with a third-party service may take longer than expected due to network or service load. Extending the timeout ensures the authentication process has enough time to complete without flakiness."
    },
    {
      "input": "test('should process order and save to history', async () => { await processOrder(123); const history = getOrderHistory(123); expect(history).toContain('Processed'); });",
      "output": "Isolate State: Shared order history between tests can cause interference. Resetting the order history ensures that each test runs independently."
    },
    {
      "input": "async function getCheckoutDuration(userId) { const response = await fetch(`/api/users/${userId}/checkout-duration`); return await response.json(); } test('should return exact checkout duration', async () => { const duration = await getCheckoutDuration(201); expect(duration).toBe(120); });",
      "output": "Widen Assertion: Checkout duration may vary slightly based on server load or user behavior. Adjust the assertion accordingly."
    },
    {
      "input": "test('should display loading spinner while fetching data', async () => { fetchData(); expect(document.querySelector('#loading').style.display).toBe('block'); });",
      "output": "Add/Adjust Wait: The loading spinner appears asynchronously, so adding a wait ensures it is visible before the test proceeds."
    },
    {
      "input": "test('should display user profile after data fetch', async () => { loadUserProfile(); expect(document.querySelector('#profile').textContent).toContain('John Doe'); });",
      "output": "Add/Adjust Wait: The profile data loads asynchronously, and the DOM may not be updated immediately. Adding a wait ensures the data is rendered before the assertion."
    },
    {
      "input": "test('should return exactly 10 search results', async () => { const results = await performSearch(); expect(results.length).toBe(10); });",
      "output": "Widen Assertion: Search results may vary, and expecting exactly 10 results could lead to flakiness. Widening the assertion to allow a range of results increases reliability."
    },
    {
      "input": "test('should validate insurance claim', async () => { await validateClaim(); const result = getClaimStatus(); expect(result.valid).toBe(true); });",
      "output": "Isolate State: Insurance claim state may be shared across tests, leading to test interference. Resetting the claim state ensures tests run independently."
    },
    {
      "input": "async function getEventTickets(eventId) { const response = await fetch(`https://api.ticketmaster.com/event/${eventId}/tickets`); return await response.json(); } test('should fetch tickets for event 333', async () => { const tickets = await getEventTickets(333); expect(tickets.length).toBeGreaterThan(0); });",
      "output": "Add Mock: The test becomes flaky due to reliance on real-time ticket availability from an external API. Mocking the response ensures consistent behavior."
    },
    {
      "input": "test('should successfully submit an order', async () => { const result = await submitOrder(orderData); expect(result.status).toBe('Success'); });",
      "output": "Handle Timeout: Submitting an order through an external payment gateway may take longer than expected due to network latency. Extending the timeout ensures that the order submission process has enough time to complete without causing test failures."
    },
    {
      "input": "test('should upload large spreadsheet file within 2 seconds', async () => { const result = await uploadSpreadsheet('sheet.xlsx'); expect(result.success).toBe(true); }, 2000);",
      "output": "Handle Timeout: Spreadsheet files may take longer to upload due to their size. Extending the timeout allows the upload to complete without causing test failures."
    },
    {
      "input": "let messages = []; async function addMessage(message) { messages.push(message); return messages; } test('should add message', async () => { const updatedMessages = await addMessage('Hello'); expect(updatedMessages.length).toBe(1); });",
      "output": "Isolate State: The messages array persists between tests, leading to incorrect results. Resetting the state ensures isolation."
    },
    {
      "input": "test('should activate next button after user fills form', async () => { fillForm(); expect(document.querySelector('#next-btn').disabled).toBe(false); });",
      "output": "Add/Adjust Wait: Waiting for form validation ensures the button becomes enabled asynchronously."
    },
    {
      "input": "async function processWebSocketData() { const ws = new WebSocket('wss://api.example.com'); return new Promise((resolve, reject) => { ws.onmessage = (event) => { resolve(event.data); }; ws.onerror = (error) => { reject(error); }; }); } test('should process WebSocket data', async () => { const data = await processWebSocketData(); expect(data).toBeDefined(); });",
      "output": "Handle Timeout: WebSocket connections can be affected by network latency or server delays, leading to intermittent failures in tests. By setting a timeout mechanism to handle potential delays in receiving WebSocket data, we ensure the test does not fail prematurely and can accommodate varying network conditions."
    },
    {
      "input": "test('should return exactly 3 search results', async () => { const results = await searchItems(); expect(results.length).toBe(3); });",
      "output": "Widen Assertion: The search results may vary slightly between 3 and 5 due to dynamic data. Widening the assertion allows flexibility for minor fluctuations in results."
    },
    {
      "input": "let cart = require('./cart'); async function addToCart(item) { cart.items.push(item); } test('should add item to cart', async () => { await addToCart({ name: 'Laptop', price: 1200 }); expect(cart.items.length).toBe(1); });",
      "output": "Isolate State: Using Jest.resetModules to ensure cart state isolation."
    },
    {
      "input": "async function provisionElasticIp() { return new Promise(resolve => { setTimeout(() => resolve('Elastic IP Provisioned'), 6000); }); } test('should provision Elastic IP', async () => { const result = await provisionElasticIp(); expect(result).toBe('Elastic IP Provisioned'); });",
      "output": "Handle Timeout: Provisioning Elastic IP addresses can take time. Increase the timeout to ensure the test completes successfully."
    },
    {
      "input": "async function fetchNewsHeadlines() { const response = await fetch('https://api.news.com/headlines'); return await response.json(); } test('should fetch top headlines', async () => { const headlines = await fetchNewsHeadlines(); expect(headlines[0]).toBeDefined(); });",
      "output": "Add Mock: Mocking the news API ensures the test won't fail due to external changes."
    },
    {
      "input": "test('should close cloud storage connection after uploading file', async () => { const cloud = await connectToCloud(); await uploadFile(cloud, 'file.zip'); expect(cloud.isClosed()).toBe(true); });",
      "output": "Manage Resource: Cloud storage connections should be closed after use to avoid resource depletion. Ensuring the connection is closed resolves this issue."
    },
    {
      "input": "test('should save image to database', async () => { const db = await openDatabaseConnection(); await db.saveImage('image.png'); expect(db.hasImage('image.png')).toBe(true); });",
      "output": "Manage Resource: Ensures that the database connection is properly closed after saving the image."
    },
    {
      "input": "test('should fetch order data within timeout', async () => { const order = await fetchOrder(); expect(order).toBeDefined(); });",
      "output": "Handle Timeout: Using Promise.race to enforce a timeout on fetching order data."
    },
    {
      "input": "async function fetchAdCampaignStatistics(campaignId) { const response = await fetch(`/api/campaigns/${campaignId}/statistics`); return await response.json(); } test('should return ad campaign statistics', async () => { const stats = await fetchAdCampaignStatistics(402); expect(stats.conversionRate).toBe(0.05); });",
      "output": "Add Mock: Flaky behavior can occur due to the variability of campaign statistics from external APIs. Mocking the API ensures the test runs reliably with controlled data."
    },
    {
      "input": "async function fetchCryptoPrice(symbol) { const response = await fetch(`/api/crypto/${symbol}/price`); return await response.json(); } test('should fetch cryptocurrency price', async () => { const price = await fetchCryptoPrice('BTC'); expect(price).toBe(50000); });",
      "output": "Add Mock: Cryptocurrency prices fluctuate rapidly, leading to test instability. Mocking the API ensures stable test outcomes."
    },
    {
      "input": "test('should update user profile with avatar upload and state update', async () => { const userId = await getUserId(); const avatarPath = 'path/to/avatar.jpg'; const uploadResult = await uploadAvatar(userId, avatarPath); expect(uploadResult).toBeTruthy(); const updatedUserProfile = await getUserProfile(userId); expect(updatedUserProfile.avatar).toEqual(avatarPath); });",
      "output": "Handle Timeout: Flaky async interactions like avatar uploads and state updates can sometimes take longer due to network latency or server processing. By increasing the timeout for the test, we allow sufficient time for these operations to complete without prematurely failing the test."
    },
    {
      "input": "async function backupAppData() { return new Promise(resolve => setTimeout(() => resolve('Backup Complete'), 12000)); } test('should backup app data', async () => { const result = await backupAppData(); expect(result).toBe('Backup Complete'); });",
      "output": "Handle Timeout: Backing up app data may take longer than expected, depending on the amount of data. Extend the timeout."
    },
    {
      "input": "test('should return cart with items', async () => { const cart = await getCart(); expect(cart).toEqual({ items: [{ id: 1, name: 'Phone', quantity: 1 }], totalPrice: 500 }); });",
      "output": "Widen Assertion: Partial deep matching for cart item details."
    },
    {
      "input": "async function getProductRecommendations(userId) { const response = await fetch(`/api/users/${userId}/recommendations`); return await response.json(); } test('should fetch product recommendations for a user', async () => { const recommendations = await getProductRecommendations(101); expect(recommendations.length).toBe(3); });",
      "output": "Add Mock: Recommendations APIs are dependent on user data and external services, which can cause flakiness. Mocking the response ensures the test remains stable and predictable."
    },
    {
      "input": "test('should fetch user details within 500ms', async () => { const user = await fetchUserWithRetry(); expect(user).toBeDefined(); }, 500);",
      "output": "Handle Timeout: User fetching can take longer, especially when retrying due to network errors. Increasing the timeout ensures the retry mechanism has enough time to complete."
    },
    {
      "input": "test('should close cloud storage connection after data upload', async () => { const cloud = await connectToCloudStorage(); await uploadData(cloud, 'file.txt'); expect(cloud.isClosed()).toBe(true); });",
      "output": "Manage Resource: Cloud storage connections left open can cause resource depletion. Ensuring they are closed after uploads resolves this issue."
    },
    {
      "input": "test('should reset user preferences before updating profile', async () => { updateUserPreferences({ theme: 'dark' }); const preferences = await fetchUserPreferences(); expect(preferences.theme).toBe('dark'); });",
      "output": "Isolate State: User preferences from previous tests may persist, causing unexpected results. Resetting the preferences ensures clean test execution."
    },
    {
      "input": "test('should retrieve transaction details from payment processor', async () => { const details = await getTransactionDetails(); expect(details.amount).toBeGreaterThan(0); });",
      "output": "Handle Timeout: Payment processors may take longer to return transaction details during peak times. Extending the timeout ensures the test waits long enough."
    },
    {
      "input": "async function getSession(sessionService) { return await sessionService.fetchSession(); } test('should fetch session data from API', async () => { const sessionService = new SessionService(); const session = await getSession(sessionService); expect(session).toBeDefined(); });",
      "output": "Add Mock: Using mock server to simulate session API responses."
    },
    {
      "input": "test('should open and close file stream for loan document', async () => { const file = await openFileStream('loanDocument.pdf'); await file.read(); });",
      "output": "Manage Resource: File streams must be closed after use to avoid locking issues or resource leaks."
    },
    {
      "input": "let logs = []; async function logEvent(event) { logs.push(event); } test('should log event', async () => { await logEvent('User Login'); expect(logs.length).toBe(1); });",
      "output": "Isolate State: The shared 'logs' array can lead to interference between tests, potentially causing unexpected results. By isolating the state and creating a new 'logs' array for each test, we ensure that each test operates on its own log data."
    },
    {
      "input": "test('should show rewards popup after animation', async () => { triggerRewardsAnimation(); expect(document.querySelector('.rewards-popup').classList).toContain('visible'); });",
      "output": "Add/Adjust Wait: Animations for rewards popups may not complete immediately. Adding a wait ensures the popup becomes visible after the animation finishes."
    },
    {
      "input": "async function getProduct(api) { return await api.getProduct(); } test('should fetch product', async () => { const api = new ProductApi(); const product = await getProduct(api); expect(product).toBeDefined(); });",
      "output": "Add Mock: Injecting a mock API service for fetching product data."
    },
    {
      "input": "test('should show exactly 4 featured images for the blog post', async () => { const images = await fetchBlogPostImages('blog987'); expect(images.length).toBe(4); });",
      "output": "Widen Assertion: The number of featured images may change based on the blog's content update. Widening the range ensures the test passes even with minor changes."
    },
    {
      "input": "async function processUserData(userData) { await saveUserData(userData); await sendNotification('User data saved'); } test('should process user data and send notification', async () => { const userData = { name: 'Alice', email: 'alice@example.com' }; await processUserData(userData); expect(notifications.length).toBe(1); });",
      "output": "Widen Assertion: The test currently checks for an exact number of notifications, which may vary due to timing issues. Widening the assertion to check for at least one notification ensures the test remains reliable despite potential slight delays in notification delivery."
    },
    {
      "input": "test('should create and delete temporary file', async () => { const tempFile = await createTempFile(); await tempFile.write('data'); });",
      "output": "Manage Resource: Temporary files should be deleted after use to prevent resource accumulation and ensure proper file handling in other tests."
    },
    {
      "input": "test('should display cart total after item is added', async () => { addItemToCart('item1'); expect(document.querySelector('#total').textContent).toBe('$100'); });",
      "output": "Add/Adjust Wait: Cart total updates asynchronously after adding items. Adding a wait ensures the total is updated before asserting."
    },
    {
      "input": "test('should reset user session before login', async () => { loginUser('user-001'); const session = await fetchUserSession('user-001'); expect(session.isLoggedIn).toBe(true); });",
      "output": "Isolate State: Previous user sessions may interfere with login tests. Resetting the session ensures isolated behavior."
    },
    {
      "input": "let playbackSessions = {}; async function startPlaybackSession(videoId) { playbackSessions[videoId] = { started: true }; return playbackSessions; } test('should start playback session', async () => { const sessions = await startPlaybackSession('vid123'); expect(sessions['vid123'].started).toBe(true); });",
      "output": "Isolate State: The `playbackSessions` object should be reset before each test to ensure state isolation."
    },
    {
      "input": "test('should get data from third-party API', async () => { const data = await fetchThirdPartyData(); expect(data.success).toBe(true); });",
      "output": "Handle Timeout: Third-party APIs might take longer to respond, causing flaky behavior. Increasing the test timeout ensures the process completes."
    },
    {
      "input": "test('should retrieve 12 user notifications', async () => { const notifications = await fetchUserNotifications(); expect(notifications.length).toBe(12); });",
      "output": "Widen Assertion: Notifications may vary slightly, so allowing a range increases test reliability."
    },
    {
      "input": "async function sendEmail() { const mailer = openMailerService(); mailer.on('send', info => console.log('Email sent:', info)); return new Promise(resolve => { mailer.on('close', resolve); }); } test('should send email and clean up mailer listeners', async () => { const result = await sendEmail(); expect(result).toBeDefined(); });",
      "output": "Manage Resource: Using event listeners for cleaning up after email sending."
    },
    {
      "input": "test('should acquire and release lock on delivery vehicle', async () => { const lock = await acquireVehicleLock('vehicle456'); await performVehicleOperation(); });",
      "output": "Manage Resource: Locks on delivery vehicles should be released after use to avoid resource contention and deadlocks."
    },
    {
      "input": "async function getInsuranceInfo(patientId) { const response = await fetch(`https://api.healthcare.com/patients/${patientId}/insurance`); return await response.json(); } test('should fetch insurance info for patient 110', async () => { const info = await getInsuranceInfo(110); expect(info.policyNumber).toBeDefined(); });",
      "output": "Add Mock: Mocking insurance API call to prevent the test from failing due to network issues or changing data."
    },
    {
      "input": "async function slowDatabaseQuery() { return new Promise(resolve => setTimeout(() => resolve('query result'), 10000)); } test('should handle slow database query', async () => { const result = await slowDatabaseQuery(); expect(result).toBe('query result'); });",
      "output": "Handle Timeout: The database query exceeds the default test timeout. Increasing the timeout resolves the issue."
    },
    {
      "input": "let notificationList = []; test('should add notification', async () => { notificationList = await addNotification('Alert'); expect(notificationList.length).toBe(1); }); test('should clear notifications', async () => { notificationList = await clearNotifications(); expect(notificationList.length).toBe(0); });",
      "output": "Isolate State: Notification list should be reset between tests to avoid shared state issues."
    },
    {
      "input": "test('should show exactly 5 active tasks', async () => { const tasks = await fetchActiveTasks(); expect(tasks.length).toBe(5); });",
      "output": "Widen Assertion: Task numbers can change slightly, making the test flaky. Widening the assertion allows for minor variations in the result."
    },
    {
      "input": "async function showLoadingIndicator() { document.querySelector('#loading').style.display = 'block'; setTimeout(() => { document.querySelector('#loading').style.display = 'none'; }, 500); } test('should hide loading indicator after timeout', async () => { await showLoadingIndicator(); const display = document.querySelector('#loading').style.display; expect(display).toBe('none'); });",
      "output": "Add/Adjust Wait: The test is flaky because it doesn\u2019t wait for the loading indicator to hide. Refactor the function to use promises to ensure it completes before the assertion."
    },
    {
      "input": "let session = { achievementsUnlocked: 0 }; async function unlockAchievement() { session.achievementsUnlocked += 1; } test('should unlock achievement in the session', async () => { await unlockAchievement(); expect(session.achievementsUnlocked).toBe(1); });",
      "output": "Isolate State: Sharing achievements state across tests can cause flaky behavior. Isolating the session ensures stability and independence between tests."
    },
    {
      "input": "async function downloadGameUpdate(updateId) { return new Promise(resolve => setTimeout(() => resolve('Update Downloaded'), 10000)); } test('should download game update', async () => { const result = await downloadGameUpdate('update123'); expect(result).toBe('Update Downloaded'); });",
      "output": "Handle Timeout: Large game updates may take longer to download. Adjust the timeout to accommodate for this."
    },
    {
      "input": "async function fetchFitnessGoals() { const response = await fetch('https://api.fitnessapp.com/goals'); return await response.json(); } test('should fetch fitness goals', async () => { const goals = await fetchFitnessGoals(); expect(goals.length).toBe(2); });",
      "output": "Add Mock: Mocking fitness goals API request to avoid flakiness caused by external dependencies."
    },
    {
      "input": "test('should enable submit button after user input', async () => { simulateUserInput(); expect(document.querySelector('#submit').disabled).toBe(false); });",
      "output": "Add/Adjust Wait: The submit button is enabled asynchronously after user input, so a wait is required."
    },
    {
      "input": "let videoPlayer; async function playVideo(url) { videoPlayer = document.createElement('video'); videoPlayer.src = url; return new Promise(resolve => { videoPlayer.onloadeddata = () => resolve('Video playing'); }); } test('should play video', async () => { const result = await playVideo('/video.mp4'); expect(result).toBe('Video playing'); });",
      "output": "Manage Resource: Video resources can remain open between tests, causing memory leaks. Ensure the video player is stopped and removed after each test."
    },
    {
      "input": "async function fetchNotifications(api) { return await api.getNotifications(); } test('should fetch notifications', async () => { const api = new NotificationService(); const notifications = await fetchNotifications(api); expect(notifications).toBeDefined(); });",
      "output": "Add Mock: Using proxyquire to mock NotificationService dynamically."
    },
    {
      "input": "test('should display exactly 5 failed tests in CI build', async () => { const tests = await fetchFailedTests('build123'); expect(tests.length).toBe(5); });",
      "output": "Widen Assertion: The number of failed tests may vary based on build results. Widening the assertion ensures flexibility in different testing scenarios."
    },
    {
      "input": "test('should apply taxes and show total as $99', async () => { const total = await calculateTotalWithTaxes(); expect(total).toBe(99); });",
      "output": "Widen Assertion: Tax calculations can vary depending on rounding, so widening the range ensures the test passes even with minor differences."
    },
    {
      "input": "test('should download invoice within 3 seconds', async () => { const invoice = await downloadInvoice(); expect(invoice.success).toBe(true); }, 3000);",
      "output": "Handle Timeout: Downloading an invoice, especially with large order details, may exceed a short timeout. Extending the timeout ensures that the download completes before the test fails."
    },
    {
      "input": "let profile = require('./profile'); async function updateProfile(name) { profile.name = name; } test('should update profile name', async () => { await updateProfile('Alice'); expect(profile.name).toBe('Alice'); });",
      "output": "Isolate State: Using Jest.resetModules to reset profile state."
    },
    {
      "input": "async function processWebSocketData() { const ws = new WebSocket('wss://api.example.com'); return new Promise((resolve, reject) => { ws.onmessage = event => { resolve(event.data); }; ws.onerror = error => { reject(error); }; }); } test('should process WebSocket data', async () => { const data = await processWebSocketData(); expect(data).toBeTruthy(); });",
      "output": "Handle Timeout: WebSocket connections can be affected by network latency or server delays, leading to unpredictable test execution times. By setting a timeout for the WebSocket operation, we ensure the test has sufficient time to receive and process data without prematurely failing."
    },
    {
      "input": "test('should render chart in 3 seconds', async () => { const chart = await renderChart(); expect(chart).toBeDefined(); });",
      "output": "Handle Timeout: Rendering complex charts may exceed default timeouts. Increasing the timeout ensures the process completes."
    },
    {
      "input": "async function fetchLeaderboard() { return new Promise(resolve => setTimeout(() => resolve([{ player: 'Player1', score: 5000 }]), 5000)); } test('should fetch leaderboard', async () => { const leaderboard = await fetchLeaderboard(); expect(leaderboard.length).toBeGreaterThan(0); });",
      "output": "Handle Timeout: Retrieving the leaderboard may take longer due to high server load. Increase the timeout to ensure test stability."
    },
    {
      "input": "test('should report engagement rate as 8%', async () => { const engagementRate = await getEngagementRate(); expect(engagementRate).toBe(8); });",
      "output": "Widen Assertion: Engagement rates can fluctuate slightly due to changes in real-time data. Widening the acceptable range ensures the test passes with minor variations."
    },
    {
      "input": "let cart = { total: 50 }; async function applyDiscount(discount) { cart.total -= discount; } test('should apply discount to cart', async () => { await applyDiscount(5); expect(cart.total).toBe(45); });",
      "output": "Isolate State: Using testdouble to isolate cart total state."
    },
    {
      "input": "async function connectToPlayerNotifications() { const socket = new WebSocket('wss://notifications.example.com'); return socket; } test('should connect to player notifications WebSocket', async () => { const socket = await connectToPlayerNotifications(); expect(socket.readyState).toBe(1); });",
      "output": "Manage Resource: WebSocket connections for player notifications need to be closed after use. Using a `finally` block ensures that the WebSocket is properly closed after the test completes."
    },
    {
      "input": "let userLoggedIn = false; async function applyTask1() { userLoggedIn = true; } async function logout() { userLoggedIn = false; } test('should handle user applyTask1 and logout', async () => { await applyTask1(); await logout(); expect(userLoggedIn).toBe(false); });",
      "output": "Isolate State: In this scenario, the test relies on a shared 'userLoggedIn' state variable, which can lead to interference when multiple tests are running concurrently. By isolating the user state within each test, we ensure that login and logout operations are independent and do not affect other tests."
    },
    {
      "input": "test('should hide spinner after loading data', async () => { loadData(); expect(document.querySelector('#spinner').style.display).toBe('none'); });",
      "output": "Add/Adjust Wait: The spinner is hidden asynchronously after the data is loaded. Adding a wait ensures proper assertion timing."
    },
    {
      "input": "let dbConnection; async function connectToDatabase() { dbConnection = await db.connect(); return dbConnection; } test('should connect to database', async () => { const connection = await connectToDatabase(); expect(connection).toBeDefined(); });",
      "output": "Manage Resource: Ensure database connections are closed after each test to prevent resource leaks."
    },
    {
      "input": "test('should display list of articles after entering search', async () => { inputSearchTerm('React'); expect(document.querySelector('.article-list').children.length).toBeGreaterThan(0); });",
      "output": "Add/Adjust Wait: The list of articles may take time to appear due to debounce or async data fetching. Adding a wait ensures the list is rendered before assertion."
    },
    {
      "input": "async function getGpsAccuracy() { return await navigator.geolocation.getCurrentPosition().accuracy; } test('should return exact GPS accuracy', async () => { const accuracy = await getGpsAccuracy(); expect(accuracy).toBe(10); });",
      "output": "Widen Assertion: GPS accuracy can vary slightly due to environmental factors. Widen the assertion."
    },
    {
      "input": "async function fetchTrendingHashtags() { const response = await fetch('https://api.social.com/trending-hashtags'); return await response.json(); } test('should fetch trending hashtags', async () => { const hashtags = await fetchTrendingHashtags(); expect(hashtags[0]).toBe('#trending'); });",
      "output": "Add Mock: Mock the social media API to simulate retrieving trending hashtags."
    },
    {
      "input": "let cart = { items: [], totalPrice: 0 }; async function addItemToCart(item) { cart.items.push(item); cart.totalPrice += item.price; } test('should add item to cart and update price', async () => { await addItemToCart({ name: 'Book', price: 20 }); expect(cart.totalPrice).toBe(20); });",
      "output": "Isolate State: Using localStorage to isolate cart state."
    },
    {
      "input": "test('should return exactly 15 items in cart', async () => { const cart = await getCart(); expect(cart.items.length).toBe(15); });",
      "output": "Widen Assertion: The number of items in the cart may vary due to inventory changes, so widening the assertion prevents test failures from slight fluctuations."
    },
    {
      "input": "let httpConnection = openHttpConnection(); async function makeRequest() { return await httpConnection.get('/endpoint'); } test('should make HTTP request', async () => { const response = await makeRequest(); expect(response).toBeDefined(); });",
      "output": "Manage Resource: Using resource pooling for HTTP connections."
    },
    {
      "input": "test('should show shipping options after entering address', async () => { enterShippingAddress('123 Main St'); expect(document.querySelectorAll('.shipping-option').length).toBe(3); });",
      "output": "Add/Adjust Wait: Shipping options load asynchronously based on the user\u2019s address. Adding a wait ensures they are displayed before making assertions."
    },
    {
      "input": "test('should show cart icon when an item is added to the cart', async () => { addItemToCart(); expect(document.querySelector('#cart-icon').style.display).toBe('block'); });",
      "output": "Add/Adjust Wait: Using MutationObserver to detect the insertion of the cart icon in the DOM."
    },
    {
      "input": "test('should display match history after API call', async () => { loadMatchHistory('player-001'); expect(document.querySelectorAll('.match-result').length).toBe(5); });",
      "output": "Add/Adjust Wait: Match history may take time to load from the backend. Adding a wait ensures the results are displayed before assertions."
    },
    {
      "input": "test('should reset notification history before fetching new notifications', async () => { const notifications = await fetchNotifications(); expect(notifications.length).toBe(0); });",
      "output": "Isolate State: Notification history from previous tests may interfere with the current test. Resetting the notification history ensures isolated execution."
    },
    {
      "input": "async function getBlogPosts() { const response = await fetch('/api/blog/posts'); return await response.json(); } test('should fetch blog posts successfully', async () => { const posts = await getBlogPosts(); expect(posts.length).toBeGreaterThan(0); });",
      "output": "Add Mock: API calls can be flaky due to network variability. Mocking eliminates this dependency."
    },
    {
      "input": "test('should return exactly 3 shipping options for user', async () => { const options = await fetchShippingOptions(); expect(options.length).toBe(3); });",
      "output": "Widen Assertion: Shipping options can vary depending on location, time, and carrier availability. Widening the assertion ensures the test can handle variability."
    },
    {
      "input": "async function processFile() { const file = await readFile('example.txt'); return file.toUpperCase(); } test('should process file contents', async () => { const result = await processFile(); expect(result).toBe('HELLO WORLD'); });",
      "output": "Add/Adjust Wait: File reading operation is asynchronous and may not complete before the test assertion. Adding a wait ensures that the file is fully read before processing its contents, preventing premature assertion failures."
    },
    {
      "input": "async function getOrderDetails(service) { const response = await service.fetchOrder(); return await response.json(); } test('should fetch order details', async () => { const service = new OrderService(); const order = await getOrderDetails(service); expect(order.id).toBe(123); });",
      "output": "Add Mock: Using dependency injection to inject a mock service for fetching order details, decoupling the test from external APIs."
    },
    {
      "input": "test('should return exactly 8 popular items from catalog', async () => { const items = await fetchPopularItems(); expect(items.length).toBe(8); });",
      "output": "Widen Assertion: Popular items in the catalog may fluctuate based on sales or trends. Widening the assertion ensures flexibility in test results."
    },
    {
      "input": "test('should close gyroscope sensor after reading data', async () => { const sensor = await openGyroscope(); await readGyroData(sensor); expect(sensor.isClosed()).toBe(true); });",
      "output": "Manage Resource: Gyroscope sensors should be closed after use to prevent excessive battery consumption. Closing ensures efficient resource management."
    },
    {
      "input": "test('should reset notification settings before enabling push notifications', async () => { await enablePushNotifications(); const settings = await fetchNotificationSettings(); expect(settings.pushEnabled).toBe(true); });",
      "output": "Isolate State: Notification settings from previous tests may persist and affect the current test. Resetting the settings ensures isolated and clean behavior."
    },
    {
      "input": "test('should update user profile after multi-step process', async () => { let userId; await userService.createUser().then(id => { userId = id; }); await profileService.updateProfile(userId, { name: 'John Doe' }); const updatedProfile = await profileService.getProfile(userId); expect(updatedProfile.name).toBe('John Doe'); });",
      "output": "Add/Adjust Wait: The test relies on asynchronous operations with promises and multiple service calls, leading to potential race conditions and incomplete state management. By adding appropriate waits between steps, we can ensure that each operation completes before proceeding, thus preventing flakiness caused by dependencies not being resolved in time."
    },
    {
      "input": "async function getNotifications(notificationService) { return await notificationService.fetchNotifications(); } test('should fetch notifications from API', async () => { const notificationService = new NotificationService(); const notifications = await getNotifications(notificationService); expect(notifications).toBeDefined(); });",
      "output": "Add Mock: Using mock server to simulate notifications API responses."
    },
    {
      "input": "async function activateCampaignTrackingPixel(pixelId) { const response = await activatePixel(pixelId); return response; } test('should activate tracking pixel for campaign', async () => { const response = await activateCampaignTrackingPixel('pixel456'); expect(response.success).toBe(true); });",
      "output": "Manage Resource: Tracking pixels can consume system resources if not properly deactivated. Cleaning up the pixel after activation ensures efficient resource management."
    },
    {
      "input": "async function getUserNotificationSettings(userId) { const response = await fetch(`/api/users/${userId}/notifications`); return await response.json(); } test('should fetch user notification settings', async () => { const settings = await getUserNotificationSettings(101); expect(settings.email).toBe(true); });",
      "output": "Add Mock: Mock the user notification settings API to stabilize the test and avoid network dependencies."
    },
    {
      "input": "async function checkProductStatus(productId) { const response = await fetch(`/api/products/${productId}/status`); return await response.json(); } test('should check the status of a product', async () => { const status = await checkProductStatus(500); expect(status.available).toBe(true); });",
      "output": "Add Mock: The product status API can vary due to real-time data, which could cause flaky tests. Mocking the API allows for controlled responses and consistent test results."
    },
    {
      "input": "test('should return exactly 5 featured blog posts', async () => { const posts = await getFeaturedPosts(); expect(posts.length).toBe(5); });",
      "output": "Widen Assertion: The number of blog posts might vary due to content updates. Widening the assertion allows for flexibility."
    },
    {
      "input": "test('should close WebSocket connection after sending data', async () => { const ws = await openWebSocket(); await sendData(ws, 'message'); expect(ws.isClosed()).toBe(true); });",
      "output": "Manage Resource: WebSocket connections should be closed after use to avoid resource exhaustion. Closing the connection ensures proper resource management."
    },
    {
      "input": "test('should display notification after receiving a message', async () => { receiveMessage(); expect(document.querySelector('#notification').textContent).toBe('New message received'); });",
      "output": "Add/Adjust Wait: Using MutationObserver to detect text content changes in the notification area."
    },
    {
      "input": "test('should remove item from inventory', async () => { removeFromInventory('item1'); const inventory = await getInventory(); expect(inventory).not.toContain('item1'); });",
      "output": "Isolate State: Inventory data might carry over between tests. Resetting the inventory ensures independence."
    },
    {
      "input": "async function getOrderData(orderService, orderId) { return await orderService.getOrder(orderId); } test('should get order data', async () => { const orderService = new OrderService(); const order = await getOrderData(orderService, 102); expect(order).toBeDefined(); });",
      "output": "Add Mock: Using sinon to stub getOrder method for dynamic order data."
    },
    {
      "input": "test('should show the sidebar when button is clicked', async () => { clickSidebarButton(); expect(document.querySelector('#sidebar').style.display).toBe('block'); });",
      "output": "Add/Adjust Wait: Using requestAnimationFrame to wait for the sidebar to become visible."
    },
    {
      "input": "let recentOrders = []; async function addOrder(orderId) { recentOrders.push(orderId); return recentOrders; } test('should add order to recent orders', async () => { const orders = await addOrder(123); expect(orders.length).toBe(1); });",
      "output": "Isolate State: `recentOrders` persists between tests, causing state contamination. Reset the orders before each test."
    },
    {
      "input": "test('should display uploaded image after completion', async () => { uploadImage(); expect(document.querySelector('#image-preview').src).toContain('image.jpg'); });",
      "output": "Add/Adjust Wait: The image upload process takes time, and waiting ensures the preview is shown."
    },
    {
      "input": "test('should return exactly 3 code quality issues for build', async () => { const issues = await fetchCodeQualityIssues('build456'); expect(issues.length).toBe(3); });",
      "output": "Widen Assertion: Code quality issues may fluctuate based on static analysis or configuration changes. Widening the assertion ensures consistency."
    },
    {
      "input": "test('should complete database backup within 3 seconds', async () => { const result = await backupDatabase(); expect(result.success).toBe(true); }, 3000);",
      "output": "Handle Timeout: Database backups can take longer than expected depending on the size of the data. Increasing the timeout ensures the test doesn\u2019t fail due to timeouts."
    },
    {
      "input": "async function processEventData() { const data = await fetchDataFromEvent(); return processData(data); } test('should process event data', async () => { const result = await processEventData(); expect(result).toEqual({ status: 'processed' }); });",
      "output": "Add Mock: Flakiness arises due to the reliance on external data fetched by 'fetchDataFromEvent'. Mocking the data response ensures consistent results without actual network dependencies, making the test deterministic and reliable."
    },
    {
      "input": "let settings = loadSettings(); async function updateSettings(newSettings) { Object.assign(settings, newSettings); } test('should update settings', async () => { await updateSettings({ theme: 'dark' }); expect(settings.theme).toBe('dark'); });",
      "output": "Isolate State: Reloading the settings before each test run ensures that each test operates on a fresh set of settings."
    },
    {
      "input": "test('should fetch credit score within 2 seconds', async () => { const score = await getCreditScore(); expect(score).toBeGreaterThan(0); });",
      "output": "Handle Timeout: Credit score retrieval can take longer due to API or network conditions. Extending the timeout ensures the test doesn't fail prematurely."
    },
    {
      "input": "let loyaltyPoints = 100; async function redeemPoints(points) { loyaltyPoints -= points; return loyaltyPoints; } test('should redeem loyalty points', async () => { const remainingPoints = await redeemPoints(10); expect(remainingPoints).toBe(90); });",
      "output": "Isolate State: Loyalty points persist between tests, leading to inconsistent results. Reset the points before each test."
    },
    {
      "input": "test('should receive payment status from payment processor', async () => { const status = await checkPaymentStatus(); expect(status.confirmed).toBe(true); });",
      "output": "Handle Timeout: Payment processing can take longer, especially during peak times. Increasing the timeout ensures the test waits for confirmation."
    },
    {
      "input": "async function estimateDeliveryTime(zipCode) { let estimated = false; setTimeout(() => { estimated = true; }, 3000); return estimated; } test('should estimate delivery time', async () => { const result = await estimateDeliveryTime('90210'); expect(result).toBe(true); });",
      "output": "Add/Adjust Wait: Estimating delivery time might involve calls to multiple services. Adjust wait time for stability."
    },
    {
      "input": "async function fetchPayments() { const response = await fetch(`https://api.example.com/payments`); return await response.json(); } test('should fetch payment history from API', async () => { const payments = await fetchPayments(); expect(payments).toBeDefined(); });",
      "output": "Add Mock: Using nock to mock payment history API request."
    },
    {
      "input": "let userSession = { loggedIn: false }; async function logIn() { userSession.loggedIn = true; } test('should log in user', async () => { await logIn(); expect(userSession.loggedIn).toBe(true); });",
      "output": "Isolate State: Sharing session data between tests can lead to inconsistent results. Isolating the session for each test ensures reliability and avoids interference."
    },
    {
      "input": "test('should return product details', async () => { const product = await fetchProduct(); expect(product).toEqual({ id: 1, name: 'Tablet', price: 300 }); });",
      "output": "Widen Assertion: Using loose matching and type assertions to verify product data."
    },
    {
      "input": "let apiClient = openApiConnection(); async function fetchData() { return await apiClient.get('/data'); } test('should fetch data from API', async () => { const data = await fetchData(); expect(data).toBeDefined(); });",
      "output": "Manage Resource: Using async hooks and WeakRef to manage API connection cleanup."
    },
    {
      "input": "test('should display updated cart total after adding an item', async () => { addItemToCart('item1'); expect(document.querySelector('#cart-total').textContent).toBe('$50'); });",
      "output": "Add/Adjust Wait: Cart totals update asynchronously after adding an item. Adding a wait ensures that the total is updated before the check."
    },
    {
      "input": "test('should load dashboard within 2 seconds', async () => { const dashboard = await loadDashboard(); expect(dashboard.success).toBe(true); });",
      "output": "Handle Timeout: Adding a timeout ensures that the dashboard is loaded in a timely manner."
    },
    {
      "input": "test('should show exactly 4 upcoming events', async () => { const events = await fetchUpcomingEvents(); expect(events.length).toBe(4); });",
      "output": "Widen Assertion: The number of upcoming events may vary. Widening the assertion ensures flexibility in testing dynamic data."
    },
    {
      "input": "let apiConnection; async function connectToAPI() { apiConnection = await openAPIConnection(); return apiConnection; } async function disconnectAPI() { await apiConnection.disconnect(); } test('should connect and disconnect API', async () => { const connection = await connectToAPI(); expect(connection.isConnected()).toBe(true); await disconnectAPI(); expect(connection.isConnected()).toBe(false); });",
      "output": "Manage Resource: Keeping the API connection open between tests can lead to resource leaks. Closing the connection after each test fixes the issue."
    },
    {
      "input": "async function fetchStockUpdates() { const socket = new WebSocket('wss://stocks.example.com'); socket.onmessage = (msg) => updateStockPrice(msg); } test('should subscribe to stock updates via WebSocket', async () => { await fetchStockUpdates(); expect(true).toBe(true); });",
      "output": "Manage Resource: WebSocket connections for real-time data should be properly closed to avoid resource leaks. Closing the connection after use ensures system stability."
    },
    {
      "input": "test('should process payment in 500ms', async () => { const payment = await processPayment(); expect(payment.success).toBe(true); }, 500);",
      "output": "Handle Timeout: Payment processing can take slightly longer due to various factors, including network or backend load. Extending the timeout ensures stable test results."
    },
    {
      "input": "async function acquireLock() { const lock = await lockManager.acquire(); return lock; } test('should acquire lock', async () => { const lock = await acquireLock(); expect(lock).toBeTruthy(); });",
      "output": "Manage Resource: Locks should be released after use to avoid resource blocking. Ensuring the lock is released after the operation prevents issues related to locked resources in concurrent operations."
    },
    {
      "input": "test('should display player stats after loading', async () => { loadPlayerStats('player-001'); expect(document.querySelector('#player-level').textContent).toBe('10'); });",
      "output": "Add/Adjust Wait: Player stats may take time to load due to network delays. Adding a wait ensures the stats are loaded before assertions."
    },
    {
      "input": "test('should retrieve transaction history from external API', async () => { const history = await fetchTransactionHistory(); expect(history.length).toBeGreaterThan(500); });",
      "output": "Handle Timeout: Transaction history retrieval can be delayed during high traffic periods. Extending the timeout ensures the test waits for complete data."
    },
    {
      "input": "async function processOrder(orderId) { const order = await getOrderDetails(orderId); const processedOrder = await processOrderLogic(order); return processedOrder; } test('should process order successfully', async () => { const orderId = 123; const result = await processOrder(orderId); expect(result.status).toBe('processed'); });",
      "output": "Isolate State: Sharing state between async operations can lead to unexpected interactions and result in flaky tests. By isolating the state for each operation, we ensure that the test runs independently and reliably."
    },
    {
      "input": "test('should display product added to cart message', async () => { addProductToCart(); expect(document.querySelector('#cart-msg').textContent).toBe('Product added to cart'); });",
      "output": "Add/Adjust Wait: Using promise-based timeout to wait for cart message."
    },
    {
      "input": "async function fetchSettings(settingsService) { return await settingsService.getSettings(); } test('should fetch user settings', async () => { const settingsService = new SettingsService(); const settings = await fetchSettings(settingsService); expect(settings).toBeDefined(); });",
      "output": "Add Mock: Injecting mock settings service using dependency injection."
    },
    {
      "input": "test('should fetch transaction history after update', async () => { await addTransaction({ id: 1, amount: 100 }); const history = getTransactionHistory(); expect(history.length).toBeGreaterThan(0); });",
      "output": "Isolate State: Shared transaction history state across tests can lead to interference. Resetting the transaction history ensures independent test results."
    },
    {
      "input": "async function processPayment(amount) { const response = await fetch(`/payment?amount=${amount}`); return await response.json(); } test('should process payment successfully', async () => { const paymentResult = await processPayment(50); expect(paymentResult.success).toBe(true); });",
      "output": "Add Mock: External API calls introduce instability, especially when processing payments that involve real transactions. Mocking the fetch API ensures that the test runs reliably without depending on external services, providing predictable results for payment processing tests."
    },
    {
      "input": "let cacheConnection = openCacheConnection(); async function getCacheValue(key) { return await cacheConnection.get(key); } test('should fetch value from cache', async () => { const value = await getCacheValue('myKey'); expect(value).toBe('cachedValue'); });",
      "output": "Manage Resource: Using WeakSet to manage cache connection cleanup automatically."
    },
    {
      "input": "test('should display comments after submitting feedback', async () => { submitFeedback('Nice product!'); expect(document.querySelectorAll('.comment-item').length).toBe(5); });",
      "output": "Add/Adjust Wait: Comments load asynchronously after feedback submission. Adding a wait ensures that all comments are displayed before checking."
    },
    {
      "input": "async function processOrder() { const order = await getOrder(); return await validateOrder(order); } test('should process order within 5s', async () => { const result = await processOrder(); expect(result.success).toBe(true); }, 5000);",
      "output": "Handle Timeout: Async operations like processing orders can vary in execution time, especially with external dependencies like fetching orders and validating them. Setting a timeout ensures that the test allows sufficient time for the entire order processing flow to complete without prematurely failing."
    },
    {
      "input": "test('should return a status of 200', async () => { const response = await fetchData(); expect(response.status).toBe(200); });",
      "output": "Widen Assertion: HTTP status codes can vary slightly based on server behavior. Widening the assertion allows for multiple successful status codes (e.g., 200 or 204)."
    },
    {
      "input": "async function generateShippingLabel(orderId) { return new Promise(resolve => setTimeout(() => resolve('Label generated'), 5000)); } test('should generate shipping label', async () => { const result = await generateShippingLabel(123); expect(result).toBe('Label generated'); });",
      "output": "Handle Timeout: Generating shipping labels might take time due to carrier services. Increase the timeout for stability."
    },
    {
      "input": "test('should fetch exactly 4 music tracks for the user', async () => { const tracks = await fetchMusicTracks(); expect(tracks.length).toBe(4); });",
      "output": "Widen Assertion: The number of music tracks might vary depending on the user's preferences or real-time updates. Widening the assertion ensures test reliability."
    },
    {
      "input": "async function processOrders() { const orders = await fetchOrders(); return orders.filter(order => order.status === 'pending'); } test('should process pending orders', async () => { const pendingOrders = await processOrders(); expect(pendingOrders.length).toBe(3); });",
      "output": "Widen Assertion: The test currently expects exactly 3 pending orders, which may not always be consistent due to varying data inputs or processing delays. By widening the assertion to check for a range of pending orders, the test becomes more resilient to fluctuations in data processing."
    },
    {
      "input": "let userData = { loggedIn: false }; async function logIn() { userData.loggedIn = true; } test('should log in user', async () => { await logIn(); expect(userData.loggedIn).toBe(true); });",
      "output": "Isolate State: The shared user data could be affected by other tests, leading to flakiness. By isolating the state, each test runs independently without interference from other tests."
    },
    {
      "input": "async function getUserProfile() { const response = await fetch('/user/profile'); return await response.json(); } test('should fetch user profile', async () => { const profile = await getUserProfile(); expect(profile.name).toBe('Alice'); });",
      "output": "Add Mock: This test makes a real API call to fetch the user profile, which may result in flakiness due to network conditions. Mocking the API response ensures the test runs reliably without depending on external factors."
    },
    {
      "input": "async function processUserInput(input) { await validateInput(input); await saveInputToDB(input); return true; } test('should process user input', async () => { const result = await processUserInput('example'); expect(result).toBe(true); });",
      "output": "Widen Assertion: The test currently expects a boolean result without validating the specific outcome of each async operation (validation and database save). By widening the assertion to include intermediate states or error handling, the test becomes more robust against potential async failures or unexpected behaviors."
    },
    {
      "input": "async function putBucketLifecycleConfiguration(bucket, configuration) { const response = await s3.putBucketLifecycleConfiguration({ Bucket: bucket, LifecycleConfiguration: configuration }).promise(); return response; } test('should set bucket lifecycle configuration', async () => { const result = await putBucketLifecycleConfiguration('my-bucket', { Rules: [] }); expect(result).toBeDefined(); });",
      "output": "Add Mock: Mocking putBucketLifecycleConfiguration for S3."
    },
    {
      "input": "async function processOrder() { const order = await getOrder(); return await validateOrder(order); } test('should process order within 5s', async () => { const result = await processOrder(); expect(result.success).toBe(true); }, 5000);",
      "output": "Handle Timeout: Async operations, such as fetching orders and validating them, may occasionally take longer due to varying processing times or external dependencies. Extending the timeout allows the test to accommodate these potential delays and ensures that the order processing completes successfully within a reasonable timeframe."
    },
    {
      "input": "test('should enable login button after entering valid credentials', async () => { enterCredentials('username', 'password'); expect(document.querySelector('#login-button').disabled).toBe(false); });",
      "output": "Add/Adjust Wait: Form validation is an asynchronous process. Adding a wait ensures the login button is enabled before asserting."
    },
    {
      "input": "test('should close socket connection after data exchange', async () => { const socket = openSocketConnection(); await exchangeData(socket); expect(socket.isClosed()).toBe(true); });",
      "output": "Manage Resource: Leaving socket connections open can deplete resources. Ensuring sockets are closed after the test resolves this."
    },
    {
      "input": "async function fetchUserNotifications(notificationService) { return await notificationService.getNotifications(); } test('should fetch notifications', async () => { const notificationService = new NotificationService(); const notifications = await fetchUserNotifications(notificationService); expect(notifications).toBeDefined(); });",
      "output": "Add Mock: Using sinon to stub getNotifications for dynamic notification data."
    },
    {
      "input": "test('should hide modal after save completes', async () => { saveData(); expect(document.querySelector('#modal').style.display).toBe('none'); });",
      "output": "Add/Adjust Wait: The test asserts the modal is hidden too early. Adding a wait allows time for the save operation to complete and the modal to be hidden."
    },
    {
      "input": "async function startWorker() { const worker = new Worker('worker.js'); return worker; } test('should start worker', async () => { const worker = await startWorker(); expect(worker).toBeTruthy(); });",
      "output": "Manage Resource: Workers consume system resources and should be terminated after their job is done. Closing the worker ensures that resources are freed up after completion."
    },
    {
      "input": "test('should close HTTP connection after data retrieval', async () => { const connection = await openHttpConnection(); await getData(connection); expect(connection.isClosed()).toBe(true); });",
      "output": "Manage Resource: Not closing HTTP connections can lead to resource exhaustion, particularly under heavy load. Ensuring connections are closed after use resolves this issue."
    },
    {
      "input": "test('should display loading spinner after submit', async () => { submitForm(); expect(document.querySelector('#loading-spinner')).toBeDefined(); });",
      "output": "Add/Adjust Wait: Using MutationObserver to detect loading spinner appearance."
    },
    {
      "input": "let notificationList = []; test('should add a notification', async () => { notificationList = await addNotification('New message'); expect(notificationList.length).toBe(1); }); test('should clear notifications', async () => { notificationList = await clearNotifications(); expect(notificationList.length).toBe(0); });",
      "output": "Isolate State: Ensure the notification list is reset between tests to avoid interference."
    },
    {
      "input": "async function getOrderHistory() { const response = await orderService.getHistory(); return await response.json(); } test('should fetch order history', async () => { const orders = await getOrderHistory(); expect(orders.length).toBe(2); });",
      "output": "Add Mock: Mocking the internal orderService call ensures stable test results for order history retrieval."
    },
    {
      "input": "async function processOrder(orderId) { const orderDetails = await getOrderDetails(orderId); const updatedOrder = await updateOrderStatus(orderId, 'processing'); return updatedOrder; } test('should process order successfully', async () => { const orderId = '12345'; const processedOrder = await processOrder(orderId); expect(processedOrder.status).toBe('processing'); });",
      "output": "Add Mock: This test relies on external services to fetch and update order details, making it prone to flakiness due to network latency or service availability. By mocking the getOrderDetails and updateOrderStatus functions, the test can be executed reliably without external dependencies, ensuring consistent results."
    },
    {
      "input": "async function processUserData(userData) { await saveUserData(userData); await updateProfile(userData); const result = await verifyProfile(userData); return result; } test('should process user data', async () => { const userData = { name: 'Alice', age: 30 }; const result = await processUserData(userData); expect(result).toBe(true); });",
      "output": "Widen Assertion: User data processing involves multiple async operations that may have varying completion times. Instead of expecting a boolean value directly, widening the assertion to check for truthiness allows for more flexibility in handling async completion states."
    },
    {
      "input": "test('should upload large file within time limit', async () => { const result = await uploadFile(); expect(result).toBeDefined(); });",
      "output": "Handle Timeout: Using Web Worker to manage file upload with timeout."
    },
    {
      "input": "test('should display user profile after successful login', async () => { loginUser(); expect(document.querySelector('.user-profile').style.display).toBe('block'); });",
      "output": "Add/Adjust Wait: The user profile may take time to load after login. Adding a wait ensures the UI updates are complete before asserting."
    },
    {
      "input": "test('should download a video file within 5 seconds', async () => { const file = await downloadVideo('video.mp4'); expect(file).toBeDefined(); }, 5000);",
      "output": "Handle Timeout: Video files can be large, and network speed may vary. Increasing the timeout ensures that the download completes without causing test failures."
    },
    {
      "input": "test('should load reviews section when visible', async () => { loadReviews(); expect(document.querySelector('#reviews').textContent).toBe('5-star reviews'); });",
      "output": "Add/Adjust Wait: Using IntersectionObserver to wait for reviews section visibility."
    },
    {
      "input": "test('should reset user session before applying promo code', async () => { applyPromoCode('SAVE20'); const session = await getUserSession(); expect(session.appliedPromo).toBe('SAVE20'); });",
      "output": "Isolate State: User sessions may persist between tests, causing promo codes to be applied inconsistently. Resetting the session ensures test isolation."
    },
    {
      "input": "async function processOrders() { let totalOrders = 0; await fetchOrders().then(orders => { totalOrders = orders.length; }); return totalOrders; } test('should process total orders', async () => { const result = await processOrders(); expect(result).toBeGreaterThan(0); });",
      "output": "Isolate State: In the current implementation, the totalOrders variable is shared among async operations, leading to potential race conditions and incorrect results. By isolating the state within the async flow, each operation maintains its own state, ensuring reliable and consistent test outcomes."
    },
    {
      "input": "test('should increment user points', async () => { await incrementPoints(5); const points = getUserPoints(); expect(points).toBe(5); });",
      "output": "Isolate State: User points may be shared across tests, causing test failures. Resetting user points before each test ensures tests run independently."
    },
    {
      "input": "async function currentDay() { const days = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday']; return days[new Date().getDay()]; } test('should return the correct current day', async () => { const day = await currentDay(); expect(day).toBeDefined(); });",
      "output": "Add Mock: Using Sinon.js to mock Date for determining the day of the week."
    },
    {
      "input": "test('should calculate total price after discounts', async () => { const totalPrice = await calculateTotalPrice(); expect(totalPrice).toBe(100); });",
      "output": "Widen Assertion: The test is too strict by expecting the total price to be exactly 100. In real-world scenarios, discounts and pricing calculations can vary, leading to slight fluctuations in the final total price. Widening the assertion range allows for more flexibility in handling these variations."
    },
    {
      "input": "test('should update CTR after fetching ad metrics', async () => { fetchAdMetrics(); expect(document.querySelector('.ctr').textContent).toBe('5%'); });",
      "output": "Add/Adjust Wait: Fetching click-through rate (CTR) asynchronously may delay the DOM update. Adding a wait ensures that the data is updated in the DOM before making assertions."
    },
    {
      "input": "let apiClient = openApiClient(); async function fetchData() { return await apiClient.getData(); } test('should fetch data from API', async () => { const data = await fetchData(); expect(data).toBeDefined(); });",
      "output": "Manage Resource: Using WeakSet to manage API client resources."
    },
    {
      "input": "test('should update user profile after fetching data and processing', async () => { let userData; await fetchUserData().then(data => { userData = data; }); await processUserData(userData).then(() => { expect(userData.processed).toBeTruthy(); }); });",
      "output": "Handle Timeout: The test case relies on asynchronous operations to fetch user data and process it, but it does not ensure that the data is fully available before processing. By introducing a timeout mechanism that waits for the data to be fetched completely before proceeding to processing, we can eliminate potential race conditions and ensure the test's reliability."
    },
    {
      "input": "test('should show exactly 5 search results for keyword', async () => { const results = await searchForKeyword('test'); expect(results.length).toBe(5); });",
      "output": "Widen Assertion: Search results can vary slightly based on indexing and timing. Widening the assertion ensures the test handles variations gracefully."
    },
    {
      "input": "test('should download video file from streaming service', async () => { const video = await downloadVideo('movie123'); expect(video.size).toBeGreaterThan(500000); });",
      "output": "Handle Timeout: Video downloads can be slow depending on the user\u2019s network. Extending the timeout ensures the test does not fail before the download completes."
    },
    {
      "input": "async function processDatabaseTransaction() { const result = await executeTransaction(); return result; } test('should process database transaction successfully', async () => { const result = await processDatabaseTransaction(); expect(result.success).toBe(true); });",
      "output": "Widen Assertion: The test currently expects the database transaction to always succeed, which might not always be the case due to various factors like network issues or database errors. By widening the assertion to check for a range of possible outcomes, the test becomes more resilient to intermittent failures and provides a more realistic validation of the transaction process."
    },
    {
      "input": "let fileUploads = []; test('should upload a file', async () => { fileUploads = await uploadFile('file.txt'); expect(fileUploads.length).toBe(1); }); test('should clear file uploads', async () => { fileUploads = await clearUploads(); expect(fileUploads.length).toBe(0); });",
      "output": "Isolate State: Reset file uploads between tests to avoid shared state between tests."
    },
    {
      "input": "test('should enable save button after form validation', async () => { validateForm(); expect(document.querySelector('#save').disabled).toBe(false); });",
      "output": "Add/Adjust Wait: Form validation is asynchronous, and the save button is enabled only after validation. The test needs to wait for this process to complete."
    },
    {
      "input": "async function getServerTime() { return Date.now(); } test('should return exact server time', async () => { const time = await getServerTime(); expect(time).toBe(Date.now()); });",
      "output": "Widen Assertion: The test fails due to minor timing differences. Widening the assertion allows for acceptable variation in the timestamps."
    },
    {
      "input": "test('should book appointment within 2 seconds', async () => { const appointment = await bookAppointment(); expect(appointment.success).toBe(true); });",
      "output": "Handle Timeout: Booking an appointment may take longer due to server load, so increasing the timeout ensures the test passes even with delays."
    },
    {
      "input": "test('should display exactly 10 posts on feed', async () => { const posts = await getFeed(); expect(posts.length).toBe(10); });",
      "output": "Widen Assertion: Feed posts can fluctuate, so widening the assertion ensures the test passes with slight changes in the number of posts."
    },
    {
      "input": "async function checkPromoCodeValidity(code) { const response = await fetch(`/api/promo/${code}/validity`); return await response.json(); } test('should check promo code validity', async () => { const isValid = await checkPromoCodeValidity('SAVE10'); expect(isValid).toBe(true); });",
      "output": "Add Mock: Mock the promo code validation API to avoid reliance on live data for testing."
    },
    {
      "input": "let profile = { name: 'Alice', age: 25 }; async function updateProfile(updates) { Object.assign(profile, updates); } test('should update profile data', async () => { await updateProfile({ age: 26 }); expect(profile.age).toBe(26); });",
      "output": "Isolate State: Using Immutable.js to prevent profile state mutation."
    },
    {
      "input": "test('should process loan application in under 3 seconds', async () => { const start = Date.now(); await processLoanApplication(); const end = Date.now(); expect(end - start).toBeLessThan(3000); });",
      "output": "Widen Assertion: Loan applications may take varying amounts of time to process due to server load. Widening the assertion window ensures tests remain stable."
    },
    {
      "input": "let sshConnection = openSshConnection(); async function executeCommand(command) { await sshConnection.exec(command); } test('should execute command via SSH', async () => { await executeCommand('uptime'); expect(sshConnection.lastCommand).toBe('uptime'); });",
      "output": "Manage Resource: Using deferred cleanup to ensure that the SSH connection is closed after each test."
    },
    {
      "input": "let cartItems = []; async function addToCart(item) { cartItems.push(item); return cartItems; } test('should add item to cart', async () => { const cart = await addToCart('item1'); expect(cart.length).toBe(1); });",
      "output": "Isolate State: The cart persists between tests, leading to incorrect results. Resetting the cart ensures proper isolation."
    },
    {
      "input": "test('should show payment confirmation after processing', async () => { processPayment(); expect(document.querySelector('#payment-confirmation')).toBeDefined(); });",
      "output": "Add/Adjust Wait: Using async-retry to retry payment processing."
    },
    {
      "input": "async function deliverLoot(playerId, lootId) { return new Promise(resolve => setTimeout(() => resolve('Loot Delivered'), 3500)); } test('should deliver loot', async () => { const result = await deliverLoot(101, 'loot123'); expect(result).toBe('Loot Delivered'); });",
      "output": "Add/Adjust Wait: Loot delivery may take longer due to server-side processing. Add wait time for consistent test results."
    },
    {
      "input": "async function fetchSupplierDetails(supplierId) { const response = await fetch(`/api/suppliers/${supplierId}`); return await response.json(); } test('should fetch supplier details', async () => { const supplier = await fetchSupplierDetails('supplier123'); expect(supplier.name).toBe('Acme Corp'); });",
      "output": "Add Mock: The test depends on an external API to fetch supplier details. Mocking the API will eliminate network-related flakiness."
    },
    {
      "input": "test('should reset multiplayer server state before connecting', async () => { connectToServer('server-001'); const server = await fetchServerState('server-001'); expect(server.isActive).toBe(true); });",
      "output": "Isolate State: Server states from previous tests may affect new ones. Resetting the server state ensures isolated and consistent test results."
    },
    {
      "input": "async function connectToLobbyUpdates() { const socket = new WebSocket('wss://lobby-updates.example.com'); return socket; } test('should establish WebSocket connection to the lobby server', async () => { const socket = await connectToLobbyUpdates(); expect(socket.readyState).toBe(1); });",
      "output": "Manage Resource: WebSocket connections to the lobby server need to be closed after use to prevent resource exhaustion. Ensuring the WebSocket is closed in a `finally` block prevents resource leaks."
    },
    {
      "input": "test('should handle multi-step async flow with race condition', async () => { let accountSyncResultA, accountSyncResultB; fetchDataA().then(data => { accountSyncResultA = data; }); fetchDataB().then(data => { accountSyncResultB = data; }); await someOtherAsyncOperation(); expect(accountSyncResultA).toBe('expectedA'); expect(accountSyncResultB).toBe('expectedB'); });",
      "output": "Add/Adjust Wait: This test case suffers from a race condition where the assertions for resultA and resultB are made before the promises resolve, leading to intermittent failures. By adding appropriate waits for the promises to resolve, the test will ensure that the data is available before making the expectations, thus eliminating the race condition."
    },
    {
      "input": "async function fetchServerStatus(api) { return await api.getStatus(); } test('should fetch server status', async () => { const api = new ServerService(); const status = await fetchServerStatus(api); expect(status.online).toBe(true); });",
      "output": "Add Mock: Using Proxy to mock the `getStatus` call and intercept its behavior."
    },
    {
      "input": "test('should return system status with correct nested uptime details', async () => { const status = await getSystemStatus(); expect(status).toEqual({ status: 'online', uptime: { days: 2, hours: 5 } }); });",
      "output": "Widen Assertion: Using deep comparison for system status validation with nested uptime."
    },
    {
      "input": "async function connectToExternalAPI() { const connection = await apiConnector.connect(); return connection; } test('should connect to external API', async () => { const connection = await connectToExternalAPI(); expect(connection).toBeTruthy(); });",
      "output": "Manage Resource: Connections to external APIs must be closed after use to avoid resource leaks. Properly managing the connection prevents resource exhaustion."
    },
    {
      "input": "async function processFile() { const file = await readFile('example.txt'); return file.toUpperCase(); } test('should process file content', async () => { const result = await processFile(); expect(result).toBe('HELLO WORLD'); });",
      "output": "Add/Adjust Wait: File reading operation is asynchronous and may not complete before the test assertion. Adding a wait ensures that the file content is processed after it has been fully read."
    },
    {
      "input": "async function fetchWeatherData() { const response = await fetch('https://api.weather.com/current'); return await response.json(); } test('should fetch weather data within timeout', async () => { const weather = await fetchWeatherData(); expect(weather).toBeDefined(); });",
      "output": "Handle Timeout: Using AbortController to enforce timeout on weather data fetching."
    },
    {
      "input": "test('should display battery status after fetching data from API', async () => { fetchBatteryStatus(); expect(document.querySelector('#battery-status').textContent).toBe('Charging'); });",
      "output": "Add/Adjust Wait: Battery status may take time to fetch due to async operations. Adding a wait ensures the status is displayed correctly before assertions."
    },
    {
      "input": "let websocket; async function openWebSocket() { websocket = new WebSocket('wss://example.com'); return websocket; } test('should open WebSocket connection', async () => { const ws = await openWebSocket(); expect(ws).toBeDefined(); });",
      "output": "Manage Resource: WebSocket connections should be closed after each test to prevent resource leaks."
    },
    {
      "input": "async function readFile() { const file = openFile('/path/to/file'); return file.read(); } test('should read file and close file descriptor', async () => { const content = await readFile(); expect(content).toBeDefined(); });",
      "output": "Manage Resource: Using Promise.finally to close file descriptor after reading."
    },
    {
      "input": "async function connectWebSocketForChat() { const socket = new WebSocket('wss://chat.example.com'); socket.onmessage = (msg) => handleMessage(msg); return socket; } test('should connect WebSocket for chat', async () => { const socket = await connectWebSocketForChat(); expect(socket.readyState).toBe(1); });",
      "output": "Add Mock: WebSocket-based chat systems can suffer from flaky connections. Mocking WebSocket ensures that message handling and connections are predictable for testing."
    },
    {
      "input": "test('should fetch latest news within 5 seconds', async () => { const news = await fetchLatestNews(); expect(news.length).toBeGreaterThan(0); });",
      "output": "Handle Timeout: Ensure that fetching news completes within a reasonable time by adding a timeout."
    },
    {
      "input": "test('should connect to server and disconnect after sending data', async () => { const connection = await connectToServer(); await connection.sendData('data'); });",
      "output": "Manage Resource: Server connections should be closed after use to prevent resource exhaustion and ensure proper management of server resources."
    },
    {
      "input": "async function accessClipboard() { const clipboard = await navigator.clipboard.read(); return clipboard; } test('should access clipboard', async () => { const clipboard = await accessClipboard(); expect(clipboard).toBeDefined(); });",
      "output": "Manage Resource: Clipboard access must be managed to ensure data is securely removed after usage. Clearing the clipboard after the operation ensures security and proper resource handling."
    },
    {
      "input": "test('should update balance after transaction', async () => { processTransaction(); expect(document.querySelector('#balance').textContent).toBe('$900'); });",
      "output": "Add/Adjust Wait: Using microtask to wait for balance update after transaction."
    },
    {
      "input": "test('should show loading spinner during data fetch', async () => { fetchData(); expect(document.querySelector('#loading').style.display).toBe('block'); });",
      "output": "Add/Adjust Wait: The spinner might not appear immediately, as data fetch is asynchronous. Adding a wait ensures the spinner is visible before checking."
    },
    {
      "input": "test('should load exactly 500 records from the database', async () => { const records = await fetchDatabaseRecords(); expect(records.length).toBe(500); });",
      "output": "Widen Assertion: The number of records retrieved can vary slightly due to database updates. Widening the range ensures the test remains flexible to small changes."
    },
    {
      "input": "let userWatchlist = []; async function addToWatchlist(videoId) { userWatchlist.push(videoId); return userWatchlist; } test('should add video to watchlist', async () => { const watchlist = await addToWatchlist('vid123'); expect(watchlist.length).toBe(1); });",
      "output": "Isolate State: The `userWatchlist` array should be reset between tests to avoid test contamination."
    },
    {
      "input": "test('should write log to file', async () => { const logger = await openLogFile(); await logger.write('Log entry'); expect(logger.hasWritten('Log entry')).toBe(true); });",
      "output": "Manage Resource: Ensures the log file is properly closed after writing to prevent resource exhaustion."
    },
    {
      "input": "test('should load content dynamically after button click', async () => { clickButton(); expect(document.querySelector('.dynamic-content')).toBeDefined(); });",
      "output": "Add/Adjust Wait: Using MutationObserver to detect dynamic content addition."
    },
    {
      "input": "async function getPaymentHistory() { const response = await fetch('/api/payments/history'); return await response.json(); } test('should fetch payment history', async () => { const history = await getPaymentHistory(); expect(history.length).toBe(10); });",
      "output": "Add Mock: Payment history can change frequently, leading to flakiness in tests. Mocking the API call ensures that a consistent set of data is returned each time."
    },
    {
      "input": "async function processOrder(orderId) { const orderDetails = await getOrderDetails(orderId); const updatedOrder = await updateOrderStatus(orderDetails); return updatedOrder; } test('should process order successfully', async () => { const orderId = '12345'; const result = await processOrder(orderId); expect(result.status).toBe('completed'); });",
      "output": "Add Mock: This test relies on external services getOrderDetails and updateOrderStatus, making it prone to flakiness due to network latency or service availability. By mocking these service calls, the test can execute reliably without being affected by external factors."
    },
    {
      "input": "let transactionHistory = []; async function logTransaction(transaction) { transactionHistory.push(transaction); return transactionHistory; } test('should log transaction', async () => { const history = await logTransaction({ id: 101, amount: 50 }); expect(history.length).toBe(1); });",
      "output": "Isolate State: The `transactionHistory` persists between tests. Reset the history before each test to prevent test interference."
    },
    {
      "input": "test('should return exactly 6 featured articles', async () => { const articles = await getFeaturedArticles(); expect(articles.length).toBe(6); });",
      "output": "Widen Assertion: The number of featured articles can fluctuate, causing flaky tests. Widening the assertion ensures the test is more flexible."
    },
    {
      "input": "let searchResults = []; async function addSearchResult(videoId) { searchResults.push(videoId); return searchResults; } test('should add search result', async () => { const results = await addSearchResult('vid123'); expect(results.length).toBe(1); });",
      "output": "Isolate State: The `searchResults` array should be reset between tests to prevent state sharing between tests."
    },
    {
      "input": "async function getQueryExecutionTime() { return performance.now(); } test('should match exact query execution time', async () => { const time = await getQueryExecutionTime(); expect(time).toBe(performance.now()); });",
      "output": "Widen Assertion: Query execution time may vary slightly. Widening the assertion fixes this flakiness."
    },
    {
      "input": "async function fetchProductDetails(api, productId) { return await api.getProduct(productId); } test('should fetch product details', async () => { const api = new ProductApi(); const product = await fetchProductDetails(api, 101); expect(product).toBeDefined(); });",
      "output": "Add Mock: Using jest.spyOn to mock product API getProduct method."
    },
    {
      "input": "async function processOrder(orderId) { const status = await checkOrderStatus(orderId); return status === 'completed'; } test('should process order successfully', async () => { const result = await processOrder(123); expect(result).toBe(true); });",
      "output": "Handle Timeout: Asynchronous operations like checking order status can be affected by varying network speeds or server response times, leading to test failures due to premature timeouts. By setting a longer timeout, we ensure that the operation completes within a reasonable timeframe, improving test reliability."
    },
    {
      "input": "test('should return exactly 3 active sessions for the user', async () => { const sessions = await fetchUserSessions(123); expect(sessions.length).toBe(3); });",
      "output": "Widen Assertion: Active sessions may fluctuate based on user activity. Widening the assertion accommodates these changes."
    },
    {
      "input": "async function purchaseInGameItem(playerId, itemId) { return new Promise(resolve => setTimeout(() => resolve('Purchase Complete'), 4500)); } test('should complete in-game purchase', async () => { const result = await purchaseInGameItem(101, 'item123'); expect(result).toBe('Purchase Complete'); });",
      "output": "Handle Timeout: In-game purchases may be delayed due to payment processing. Increase the test timeout to handle delays."
    },
    {
      "input": "let websocketConnection; async function connectToChatService() { websocketConnection = await ChatService.connect(); return websocketConnection; } test('should connect to chat service', async () => { const connection = await connectToChatService(); expect(connection).toBeDefined(); });",
      "output": "Manage Resource: Ensure chat service WebSocket connections are properly closed after each test to prevent unused open connections."
    },
    {
      "input": "test('should return full server status', async () => { const status = await getServerStatus(); expect(status).toEqual({ online: true, uptime: 1000, load: 0.5 }); });",
      "output": "Widen Assertion: Checking only the essential `online` status while ignoring other fields like `uptime` and `load`."
    },
    {
      "input": "test('should close database connection after saving user data', async () => { const db = await openDatabaseConnection(); await saveUserData(db, 'user-001'); expect(db.isClosed()).toBe(true); });",
      "output": "Manage Resource: Database connections should be closed after operations to prevent resource exhaustion and ensure efficient management."
    },
    {
      "input": "async function fetchPlayerStats(playerId) { const response = await fetch(`/api/players/${playerId}/stats`); return await response.json(); } test('should fetch player stats correctly', async () => { const stats = await fetchPlayerStats('player-001'); expect(stats.level).toBe(10); });",
      "output": "Add Mock: Player stats API may experience latency or fail due to network issues. Mocking the API ensures stable test results."
    },
    {
      "input": "async function saveGameProgress(progress) { return new Promise(resolve => setTimeout(() => resolve('Progress Saved'), 4000)); } test('should save game progress', async () => { const result = await saveGameProgress({ level: 10, score: 1000 }); expect(result).toBe('Progress Saved'); });",
      "output": "Handle Timeout: Saving game progress can take time due to database writes. Increase the test timeout to ensure stability."
    },
    {
      "input": "async function getPaymentHistory(paymentService) { return await paymentService.getHistory(); } test('should fetch payment history', async () => { const paymentService = new PaymentService(); const history = await getPaymentHistory(paymentService); expect(history).toBeDefined(); });",
      "output": "Add Mock: Using jest.mock() to mock PaymentService module."
    },
    {
      "input": "test('should clear shopping cart before checkout', async () => { clearCart(); const cart = await getCart(); expect(cart.items.length).toBe(0); });",
      "output": "Isolate State: The cart may retain items from previous tests. Clearing the cart ensures that each test runs with a clean state."
    },
    {
      "input": "let inventoryAuditLog = []; async function logInventoryChange(itemId, change) { inventoryAuditLog.push({ itemId, change }); return inventoryAuditLog; } test('should log inventory change', async () => { const log = await logInventoryChange('item123', 'restocked'); expect(log.length).toBe(1); });",
      "output": "Isolate State: Resetting the `inventoryAuditLog` between tests ensures logs from other tests do not interfere."
    },
    {
      "input": "let config = { language: 'en' }; async function changeLanguage(lang) { config.language = lang; } test('should change language', async () => { await changeLanguage('fr'); expect(config.language).toBe('fr'); });",
      "output": "Isolate State: Shared configuration settings can cause unintended side effects between tests. Isolate the config object to ensure independent test runs."
    },
    {
      "input": "let smtpClient = openSmtpClient(); async function sendEmail() { await smtpClient.send('email@example.com'); } test('should send an email', async () => { await sendEmail(); expect(smtpClient.sentEmails).toContain('email@example.com'); });",
      "output": "Manage Resource: Using a pooled SMTP connection to handle sending emails, ensuring proper resource cleanup after each test."
    },
    {
      "input": "async function uploadFile() { const ftp = openFtpConnection(); return ftp.upload('/file.zip'); } test('should upload file and close FTP connection', async () => { const result = await uploadFile(); expect(result).toBeDefined(); });",
      "output": "Manage Resource: Using Promise.finally to close FTP connection after upload."
    },
    {
      "input": "test('should return exactly 100 shares for the blog post', async () => { const post = await fetchBlogPostShares('blog789'); expect(post.shares).toBe(100); });",
      "output": "Widen Assertion: Shares can increase or decrease depending on user activity. Widening the range accounts for these fluctuations and ensures the test passes with minor changes."
    },
    {
      "input": "async function fetchPlayerProfile(playerId) { const response = await fetch(`/api/players/${playerId}/profile`); return await response.json(); } test('should fetch player profile', async () => { const profile = await fetchPlayerProfile(101); expect(profile.username).toBe('Player101'); });",
      "output": "Add Mock: Mock the player profile API to avoid network dependency issues and stabilize the test."
    },
    {
      "input": "test('should return product with nested supplier details', async () => { const product = await getProduct(); expect(product).toEqual({ id: 201, name: 'Tablet', supplier: { name: 'TechCorp', rating: 4.5 } }); });",
      "output": "Widen Assertion: Using deep comparison to validate nested supplier details in product."
    },
    {
      "input": "test('should display confirmation message after deletion', async () => { deleteItem(); expect(document.querySelector('#confirmation-msg').textContent).toBe('Item deleted'); });",
      "output": "Add/Adjust Wait: Using Promise.resolve().then() to wait for confirmation message."
    },
    {
      "input": "test('should display results after fetching lab data', async () => { fetchLabData(); expect(document.querySelector('.lab-data-display').textContent).toBe('Data retrieved'); });",
      "output": "Add/Adjust Wait: Lab data fetching is asynchronous, so adding a wait ensures the data is displayed before the assertion runs."
    },
    {
      "input": "async function processFile() { const fileData = await readFile('example.txt'); return processData(fileData); } test('should process file data', async () => { const result = await processFile(); expect(result).toBe('Processed Data'); });",
      "output": "Add/Adjust Wait: File reading and processing are asynchronous operations that may take time to complete. Adding a wait ensures that the file is read and processed before making assertions on the result."
    },
    {
      "input": "async function getNotifications() { return await fetch('https://api.example.com/notifications'); } test('should fetch notifications within time limit', async () => { const notifications = await getNotifications(); expect(notifications).toBeDefined(); });",
      "output": "Manage Resource: Using AbortController to cancel fetching notifications if timeout exceeded."
    },
    {
      "input": "test('should update user profile after file upload and database update', async () => { const file = await uploadFile(); const fileId = await saveFileToDatabase(file); updateUserProfile(fileId); expect(document.querySelector('.profile-updated').textContent).toBe('Profile Updated'); });",
      "output": "Add/Adjust Wait: The test fails due to the asynchronous nature of file upload, database update, and profile update operations. Adding appropriate waits ensures that each step completes before proceeding, preventing race conditions and ensuring the expected state for assertions."
    },
    {
      "input": "test('should close file handle after writing to file', async () => { const file = await openFile(); await writeToFile(file, 'Hello'); expect(file.isClosed()).toBe(true); });",
      "output": "Manage Resource: Not closing file handles can lead to resource exhaustion. Ensuring files are closed after writing prevents leaks."
    },
    {
      "input": "test('should calculate total price after applying discounts', async () => { const initialPrice = await fetchInitialPrice(); const discount = await fetchDiscount(); const totalPrice = initialPrice - discount; expect(totalPrice).toBe(50); });",
      "output": "Widen Assertion: The test is too strict by expecting the total price to be exactly 50. In real-world scenarios, discounts and prices can vary slightly due to asynchronous data fetching or calculations. Widening the assertion range allows for minor fluctuations while still ensuring correct calculations."
    },
    {
      "input": "async function fetchFriendsList() { const response = await fetch('https://api.example.com/friends'); return await response.json(); } test('should fetch friends list', async () => { const friends = await fetchFriendsList(); expect(friends.length).toBe(4); });",
      "output": "Add Mock: The test depends on a network request to an external API, which can cause instability. Mocking the response ensures consistent behavior."
    },
    {
      "input": "test('should display user settings after fetching from API', async () => { loadUserSettings(); expect(document.querySelector('#theme').textContent).toBe('dark'); });",
      "output": "Add/Adjust Wait: User settings may not be immediately available due to network latency. Adding a wait ensures settings are loaded before assertions."
    },
    {
      "input": "test('should display session timeout message', async () => { expireSession(); expect(document.querySelector('#timeout-msg').textContent).toBe('Session expired'); });",
      "output": "Add/Adjust Wait: Using MutationObserver to detect session timeout message."
    },
    {
      "input": "async function uploadVideoToCloud() { return new Promise(resolve => setTimeout(() => resolve('Video Uploaded'), 9000)); } test('should upload video to cloud', async () => { const result = await uploadVideoToCloud(); expect(result).toBe('Video Uploaded'); });",
      "output": "Handle Timeout: Uploading large video files may exceed the default timeout. Extend the timeout to handle this."
    },
    {
      "input": "test('should fetch live stock prices from external API', async () => { const prices = await fetchStockPrices(); expect(prices.length).toBeGreaterThan(0); });",
      "output": "Handle Timeout: Stock price retrieval from live APIs may be delayed due to high traffic. Extending the timeout ensures the test waits for the full data."
    },
    {
      "input": "async function getProductReviews(productId) { const response = await fetch(`/api/products/${productId}/reviews`); return await response.json(); } test('should fetch product reviews', async () => { const reviews = await getProductReviews('prod123'); expect(reviews.length).toBe(4); });",
      "output": "Add Mock: Product reviews are subject to change. Mocking the API provides consistent test results."
    },
    {
      "input": "test('should connect to EHR system and disconnect after fetching data', async () => { const connection = await connectToEHR(); const data = await connection.getData('patient123'); });",
      "output": "Manage Resource: Connections to the EHR system should be closed after use to free up resources."
    },
    {
      "input": "test('should release network resources after transferring data', async () => { const network = await openNetworkConnection(); await transferData(network, 'data'); expect(network.isReleased()).toBe(true); });",
      "output": "Manage Resource: Network connections left open can exhaust system resources. Ensuring they are closed after tests resolves this."
    },
    {
      "input": "test('should close file stream after reading data', async () => { const file = await openFile('data.txt'); await readFile(file); expect(file.isClosed()).toBe(true); });",
      "output": "Manage Resource: File streams should be closed after use to prevent resource leaks. Closing the file stream ensures proper resource management."
    },
    {
      "input": "let playerSettings = { volume: 50 }; async function updateSetting(setting, value) { playerSettings[setting] = value; return playerSettings; } test('should update player setting', async () => { const settings = await updateSetting('volume', 75); expect(settings.volume).toBe(75); });",
      "output": "Isolate State: Reset the `playerSettings` object before each test to prevent shared state across tests."
    },
    {
      "input": "test('should fetch notifications within timeout', async () => { const notifications = await getNotifications(); expect(notifications).toBeDefined(); });",
      "output": "Handle Timeout: Using Promise.race to enforce timeout on fetching notifications."
    },
    {
      "input": "test('should return exactly 5 favorite contacts', async () => { const contacts = await fetchFavoriteContacts(); expect(contacts.length).toBe(5); });",
      "output": "Widen Assertion: Favorite contacts may fluctuate based on user activity. Widening the assertion ensures the test handles variations in the number of contacts."
    },
    {
      "input": "test('should sync transaction history within 1 second', async () => { const result = await syncTransactionHistory(); expect(result.success).toBe(true); });",
      "output": "Handle Timeout: Syncing transaction history may take longer depending on server load or network issues. Increasing the timeout prevents premature test failures."
    },
    {
      "input": "async function processOrder(orderId) { const order = await getOrderDetails(orderId); const status = await checkOrderStatus(orderId); return { order, status }; } test('should process order', async () => { const result = await processOrder('12345'); expect(result).toBeDefined(); });",
      "output": "Manage Resource: The test retrieves order details and status asynchronously but does not handle potential resource leaks if the async operations fail or encounter errors. By implementing proper resource management, such as cleaning up resources in case of errors, the test can prevent resource exhaustion and ensure consistent behavior."
    },
    {
      "input": "test('should reset form state before submitting', async () => { submitForm(); const formState = await getFormState(); expect(formState.submitted).toBe(true); });",
      "output": "Isolate State: Previous form submissions may persist, causing test failures. Resetting the form state ensures clean state for each test."
    },
    {
      "input": "test('should display exactly 3 upcoming events', async () => { const events = await fetchUpcomingEvents(); expect(events.length).toBe(3); });",
      "output": "Widen Assertion: Upcoming events may fluctuate based on scheduling. Widening the assertion ensures flexibility and stability in the test."
    },
    {
      "input": "test('should receive notification in 200ms', async () => { const start = Date.now(); await receiveNotification(); const end = Date.now(); expect(end - start).toBeLessThan(200); });",
      "output": "Widen Assertion: Notifications may sometimes be delayed depending on system or network load. Widening the time frame improves test reliability."
    },
    {
      "input": "test('should complete within 500ms', async () => { const start = Date.now(); await runTask(); const duration = Date.now() - start; expect(duration).toBeLessThan(500); });",
      "output": "Widen Assertion: Task execution times can fluctuate slightly. Widening the time range to account for small variations ensures the test remains stable."
    },
    {
      "input": "async function processFileUpload() { const fileId = await uploadFile(); const status = await checkUploadStatus(fileId); return status; } test('should process file upload successfully', async () => { const result = await processFileUpload(); expect(result).toBe('uploaded'); });",
      "output": "Add Mock: This test relies on the actual file upload process, which can introduce flakiness due to network latency or file system issues. By mocking the file upload and status check functions, we can ensure consistent and reliable test outcomes, decoupling the test from external dependencies."
    },
    {
      "input": "test('should display exactly 10 recent transactions', async () => { const transactions = await getRecentTransactions(); expect(transactions.length).toBe(10); });",
      "output": "Widen Assertion: Due to minor fluctuations in transaction history, the number of recent transactions can vary. Widening the assertion ensures the test remains stable even with real-time updates."
    },
    {
      "input": "test('should show delivery date after selecting shipping method', async () => { selectShippingMethod('express'); expect(document.querySelector('#delivery-date').textContent).toContain('2 days'); });",
      "output": "Add/Adjust Wait: Delivery date appears after the shipping method is selected asynchronously. Adding a wait ensures the date is displayed before the assertion."
    },
    {
      "input": "let dbTransaction; async function startTransaction() { dbTransaction = await db.beginTransaction(); return dbTransaction; } test('should start transaction', async () => { const transaction = await startTransaction(); expect(transaction).toBeDefined(); });",
      "output": "Manage Resource: Ensure database transactions are rolled back after each test to prevent uncommitted changes."
    },
    {
      "input": "let currentLevel = 1; async function advanceLevel() { currentLevel += 1; return currentLevel; } test('should advance to the next level', async () => { const newLevel = await advanceLevel(); expect(newLevel).toBe(2); });",
      "output": "Isolate State: The `currentLevel` should be reset before each test to avoid interference between tests."
    },
    {
      "input": "test('should process insurance claim within 2 seconds', async () => { const result = await processClaim(); expect(result.approved).toBe(true); });",
      "output": "Handle Timeout: Insurance claim processing may take longer due to external service delays. Increasing the timeout ensures the test does not fail prematurely."
    },
    {
      "input": "let cart = { items: [] }; async function addItemToCart(item) { cart.items.push(item); } test('should add item to cart', async () => { await addItemToCart({ name: 'Phone', price: 800 }); expect(cart.items.length).toBe(1); });",
      "output": "Isolate State: Using dependency injection to provide isolated cart state."
    },
    {
      "input": "async function validateAddress(address) { let addressValid = false; setTimeout(() => { addressValid = true; }, 3000); return addressValid; } test('should validate address', async () => { const result = await validateAddress('123 Main St'); expect(result).toBe(true); });",
      "output": "Add/Adjust Wait: Address validation may take time due to third-party address verification services. Adjust wait time."
    },
    {
      "input": "let websocket = openWebSocketConnection(); async function sendMessage(message) { await websocket.send(message); } test('should send message via WebSocket', async () => { await sendMessage('Hello World'); expect(websocket.sentMessages).toContain('Hello World'); });",
      "output": "Manage Resource: Using WeakRef and FinalizationRegistry to handle automatic cleanup of WebSocket connections."
    },
    {
      "input": "test('should process order and close database connection', async () => { const db = await connectToDatabase(); await db.processOrder('Order1'); expect(db.processed).toBe(true); });",
      "output": "Manage Resource: Ensure the database connection is properly closed after processing an order."
    },
    {
      "input": "async function fetchOrderHistory(userId) { return new Promise(resolve => setTimeout(() => resolve([{ orderId: 1 }]), 6000)); } test('should fetch order history', async () => { const history = await fetchOrderHistory(123); expect(history.length).toBeGreaterThan(0); });",
      "output": "Handle Timeout: Order history retrieval may take time due to large data sets. Extend the test timeout."
    },
    {
      "input": "async function fetchAchievements(playerId) { const response = await fetch(`/api/players/${playerId}/achievements`); return await response.json(); } test('should fetch player achievements', async () => { const achievements = await fetchAchievements(101); expect(achievements.length).toBeGreaterThan(0); });",
      "output": "Add Mock: Mock the achievements API to prevent network delays from affecting test outcomes."
    },
    {
      "input": "async function getWeather() { const response = await fetch('/weather'); return await response.json(); } test('should fetch weather', async () => { const weather = await getWeather(); expect(weather.temperature).toBe(72); });",
      "output": "Add Mock: Flaky behavior arises due to reliance on real-time weather API. Mocking ensures the test returns consistent data and doesn't depend on external services."
    },
    {
      "input": "async function getVaccinationStatus(patientId) { const response = await fetch(`https://api.healthcare.com/patients/${patientId}/vaccination-status`); return await response.json(); } test('should fetch vaccination status for patient 407', async () => { const status = await getVaccinationStatus(407); expect(status.isVaccinated).toBe(true); });",
      "output": "Add Mock: Mocking vaccination status API call to ensure consistent test behavior and avoid flaky test failures."
    },
    {
      "input": "async function getOrderDetails(orderId) { const response = await fetch(`/api/orders/${orderId}`); return await response.json(); } test('should return correct order details', async () => { const order = await getOrderDetails(123); expect(order.id).toBe(123); });",
      "output": "Add Mock: Real API calls may lead to flaky results. Mocking the API ensures stable test execution."
    },
    {
      "input": "async function fetchCustomerOrders(customerId) { const response = await fetch(`/api/customers/${customerId}/orders`); return await response.json(); } test('should fetch customer orders', async () => { const orders = await fetchCustomerOrders(123); expect(orders.length).toBeGreaterThan(0); });",
      "output": "Add Mock: Mock the API to simulate fetching customer orders without network calls."
    },
    {
      "input": "async function processUserData(userData) { await saveUserData(userData); await updateProfile(userData); const result = await verifyProfileUpdate(); return result; } test('should process user data', async () => { const userData = { name: 'Alice', age: 30 }; const result = await processUserData(userData); expect(result).toBe(true); });",
      "output": "Widen Assertion: User data processing involves multiple async operations that may not complete instantly, leading to timing issues. By widening the assertion to check for a truthy result instead of an exact value, the test becomes more resilient to slight delays in async tasks."
    },
    {
      "input": "test('should reset wishlist before adding new item', async () => { addItemToWishlist('item1'); const wishlist = await fetchWishlist(); expect(wishlist.items.length).toBe(1); });",
      "output": "Isolate State: Wishlist data from previous tests may interfere with the current test. Resetting the wishlist ensures isolated behavior."
    },
    {
      "input": "test('should connect to delivery API and disconnect after fetching status', async () => { const api = await connectToDeliveryAPI(); const status = await api.getDeliveryStatus(); });",
      "output": "Manage Resource: Connections to the delivery API should be closed after use to avoid unnecessary resource consumption."
    },
    {
      "input": "test('should display exactly 4 top-rated movies', async () => { const movies = await fetchTopRatedMovies(); expect(movies.length).toBe(4); });",
      "output": "Widen Assertion: The number of top-rated movies can fluctuate based on user ratings. Widening the assertion allows for dynamic content updates."
    },
    {
      "input": "test('should close message queue after sending messages', async () => { const queue = await openMessageQueue(); await sendMessages(queue); expect(queue.isClosed()).toBe(true); });",
      "output": "Manage Resource: Message queues should be closed after processing to avoid resource leaks. Closing the message queue resolves this issue."
    },
    {
      "input": "async function getNotification(notificationService) { return await notificationService.getLatest(); } test('should fetch the latest notification', async () => { const notificationService = new NotificationService(); const notification = await getNotification(notificationService); expect(notification).toBeDefined(); });",
      "output": "Add Mock: Using Proxy to mock notification service behavior."
    },
    {
      "input": "test('should increment user points', async () => { await incrementPoints(5); const points = getUserPoints(); expect(points).toBe(5); });",
      "output": "Isolate State: Shared user points state can cause interference between tests. Resetting user points before each test ensures tests run independently."
    },
    {
      "input": "test('should close infrared sensor after scanning area', async () => { const infrared = await openInfraredSensor(); await scanArea(infrared); expect(infrared.isClosed()).toBe(true); });",
      "output": "Manage Resource: Infrared sensors should be turned off after use to conserve battery and processing power. Closing ensures efficient sensor resource management."
    },
    {
      "input": "test('should show updated cart count after adding item', async () => { addItemToCart('item2'); expect(document.querySelector('#cart-count').textContent).toBe('2'); });",
      "output": "Add/Adjust Wait: Cart count updates asynchronously after adding items. Adding a wait ensures the DOM is updated before the assertion."
    },
    {
      "input": "async function stopEc2Instance() { let stopped = false; setTimeout(() => { stopped = true; }, 6000); return stopped; } test('should stop EC2 instance', async () => { const result = await stopEc2Instance(); expect(result).toBe(true); });",
      "output": "Add/Adjust Wait: EC2 instance stopping can take time. Ensure the test waits for the instance to stop completely."
    },
    {
      "input": "test('should fetch exactly 3 match replays for the player', async () => { const replays = await fetchMatchReplays('player-001'); expect(replays.length).toBe(3); });",
      "output": "Widen Assertion: Match replays may vary depending on the player\u2019s recent activity. Widening the assertion ensures stable test behavior."
    },
    {
      "input": "async function fetchUserProfile(userId) { const response = await fetch(`/api/users/${userId}/profile`); return await response.json(); } test('should fetch user profile', async () => { const profile = await fetchUserProfile(123); expect(profile.name).toBe('John Doe'); });",
      "output": "Add Mock: External API calls for user profiles may be unreliable due to network conditions. Mocking the API ensures predictable test results."
    },
    {
      "input": "async function loadGameSettings() { return new Promise(resolve => setTimeout(() => resolve({ sound: true, graphics: 'high' }), 3000)); } test('should load game settings', async () => { const settings = await loadGameSettings(); expect(settings.graphics).toBe('high'); });",
      "output": "Handle Timeout: Loading game settings may take additional time due to external configuration servers. Adjust the timeout accordingly."
    },
    {
      "input": "test('should reset user data before updating profile', async () => { updateProfile({ name: 'John Doe' }); const profile = await getProfile(); expect(profile.name).toBe('John Doe'); });",
      "output": "Isolate State: Previous user data may persist, leading to incorrect results. Resetting user data ensures test isolation and consistency."
    },
    {
      "input": "test('should return search results in under 1 second', async () => { const start = Date.now(); await performSearch('query'); const end = Date.now(); expect(end - start).toBeLessThan(1000); });",
      "output": "Widen Assertion: Fuzzy search with asynchronous backend processing may occasionally take longer due to server load. Widening the time range reduces the risk of flaky tests caused by slight variations in response time."
    },
    {
      "input": "async function uploadProductImage(productId, image) { let uploaded = false; setTimeout(() => { uploaded = true; }, 7000); return uploaded; } test('should upload product image', async () => { const result = await uploadProductImage(101, 'image.jpg'); expect(result).toBe(true); });",
      "output": "Add/Adjust Wait: Uploading product images may take longer depending on file size. Adjust wait time to avoid flaky tests."
    },
    {
      "input": "async function getRefundAmount(orderId) { const response = await fetch(`/api/orders/${orderId}/refund`); return await response.json(); } test('should return exact refund amount', async () => { const refund = await getRefundAmount(123); expect(refund).toBe(50.00); });",
      "output": "Widen Assertion: Refund amounts can vary slightly due to processing fees or currency conversion. Widen the assertion to account for these variations."
    },
    {
      "input": "async function fetchEventTickets(eventId) { const response = await fetch(`/api/events/${eventId}/tickets`); return await response.json(); } test('should fetch available tickets for an event', async () => { const tickets = await fetchEventTickets(789); expect(tickets.available).toBe(20); });",
      "output": "Add Mock: Ticket availability data can fluctuate. Mocking the API ensures that the test does not fail due to real-time variability."
    },
    {
      "input": "test('should download a presentation within 4 seconds', async () => { const presentation = await downloadPresentation('slides.pptx'); expect(presentation).toBeDefined(); }, 4000);",
      "output": "Handle Timeout: Large presentations may take more time to download. Extending the timeout ensures that the test allows for slower network speeds or larger file sizes."
    },
    {
      "input": "async function runCommand() { const process = startProcess(); process.on('output', console.log); return new Promise(resolve => { process.on('exit', resolve); }); } test('should run command and clean up listeners', async () => { const result = await runCommand(); expect(result).toBeDefined(); });",
      "output": "Manage Resource: Using event listeners to clean up process resources."
    },
    {
      "input": "test('should download file within 2 seconds', async () => { const file = await downloadFile('file.pdf'); expect(file).toBeDefined(); }, 2000);",
      "output": "Handle Timeout: File downloads, especially large ones, may take longer. Increasing the timeout ensures the test doesn\u2019t fail prematurely."
    },
    {
      "input": "test('should display user profile with correct details', async () => { const profile = await getUserProfile(); expect(profile.name).toBe('Alice'); });",
      "output": "Widen Assertion: Using snapshot testing to capture and validate user profile."
    },
    {
      "input": "test('should release network resource after API request', async () => { const network = await openNetworkConnection(); await makeApiRequest(network); expect(network.isReleased()).toBe(true); });",
      "output": "Manage Resource: Not releasing network resources can lead to resource leaks. Ensuring the resource is released after each test prevents exhaustion."
    },
    {
      "input": "let stream = openStream('video.mp4'); async function streamVideo() { await stream.play(); } test('should stream video', async () => { await streamVideo(); expect(stream.isPlaying).toBe(true); });",
      "output": "Manage Resource: Ensuring the video stream is closed after the test via deferred cleanup."
    },
    {
      "input": "async function fetchGemPrices() { const response = await fetch('/game/currency/gems'); return await response.json(); } test('should fetch gem prices', async () => { const gems = await fetchGemPrices(); expect(gems.pricePerGem).toBe(5); });",
      "output": "Add Mock: External pricing APIs can lead to flakiness in tests. Mocking the gem pricing API ensures that tests are reliable and consistent without dependency on external services."
    },
    {
      "input": "test('should upload user profile picture and update user details', async () => { const uploadedFile = await uploadUserFile(); const updatedDetails = await updateUserDetails(uploadedFile); expect(updatedDetails).toBeTruthy(); });",
      "output": "Handle Timeout: In this scenario, the test involves uploading a file and updating user details, which can be time-consuming operations depending on network speed and server load. Extending the timeout allows sufficient time for these async operations to complete without prematurely failing the test."
    },
    {
      "input": "let dbConnection = openDatabase(); async function fetchOrders() { return await dbConnection.query('SELECT * FROM orders'); } test('should fetch orders from database', async () => { const orders = await fetchOrders(); expect(orders.length).toBeGreaterThan(0); });",
      "output": "Manage Resource: Using WeakMap to automatically manage the database connection and ensure it is cleaned up."
    },
    {
      "input": "test('should fetch fitness data from the API', async () => { const data = await fetchFitnessData(); expect(data.steps).toBeGreaterThan(0); });",
      "output": "Handle Timeout: Fitness data may take longer to retrieve due to backend processing. Extending the timeout ensures consistent test results."
    },
    {
      "input": "async function processUserInteraction() { await simulateUserInteraction(); await updateUI(); } test('should process user interaction', async () => { await processUserInteraction(); expect(document.querySelector('#status').textContent).toBe('Interaction Processed'); });",
      "output": "Handle Timeout: User interactions may take variable time to complete, leading to test failures if the timeout is exceeded. Extending the timeout allows sufficient time for all async operations to finish before the test assertion is made."
    },
    {
      "input": "test('should return search results in 500ms', async () => { const results = await performSearch(); expect(results.length).toBeGreaterThan(0); }, 500);",
      "output": "Handle Timeout: Search operations may take longer due to backend load or network latency. Increasing the timeout ensures the test passes reliably."
    },
    {
      "input": "test('should process database transactions', async () => { const result = await performDatabaseTransactions(); expect(result).toBeTruthy(); }, 500);",
      "output": "Handle Timeout: The test sets a timeout of 500ms, which might not be sufficient for completing database transactions, especially under heavy load or slow network conditions. By extending the timeout, the test allows for the necessary time to ensure reliable completion of async database operations."
    },
    {
      "input": "let gameTimers = []; async function startTimer(timerId) { gameTimers.push(timerId); return gameTimers; } test('should start a timer', async () => { const timers = await startTimer('timer123'); expect(timers.length).toBe(1); });",
      "output": "Isolate State: Reset the `gameTimers` array before each test to avoid test contamination."
    },
    {
      "input": "async function getNotification(service) { const notification = await service.getNotification(); return notification; } test('should fetch notification', async () => { const service = new NotificationService(); const notification = await getNotification(service); expect(notification.message).toBe('New message!'); });",
      "output": "Add Mock: Injecting a mock service and spying on the `getNotification` method call."
    },
    {
      "input": "let sshConnection; async function connectToServer() { sshConnection = await ssh.connect({ host: 'localhost', username: 'user' }); return sshConnection; } test('should connect to server', async () => { const connection = await connectToServer(); expect(connection).toBeDefined(); });",
      "output": "Manage Resource: Ensure SSH connections are closed after each test to prevent resource leaks."
    },
    {
      "input": "async function updateCartQuantity(cartId, itemId, quantity) { let quantityUpdated = false; setTimeout(() => { quantityUpdated = true; }, 4000); return quantityUpdated; } test('should update cart quantity', async () => { const result = await updateCartQuantity(1, 'item123', 5); expect(result).toBe(true); });",
      "output": "Add/Adjust Wait: Updating the quantity in the cart might take longer depending on server load. Adjust wait time."
    },
    {
      "input": "test('should acquire and release lock on warehouse inventory system', async () => { const lock = await acquireWarehouseLock('warehouse789'); await performInventoryUpdate(); });",
      "output": "Manage Resource: Locks on the warehouse inventory system should be released after use to avoid interference with other processes."
    },
    {
      "input": "test('should fetch 20 recent blog posts', async () => { const posts = await fetchBlogPosts(); expect(posts.length).toBe(20); });",
      "output": "Widen Assertion: Due to dynamic content creation, the number of blog posts may vary. Widening the range ensures that the test is stable even with slight content fluctuations."
    },
    {
      "input": "test('should fetch large image from CDN', async () => { const image = await downloadImage('image.jpg'); expect(image.size).toBeGreaterThan(200000); });",
      "output": "Handle Timeout: CDN image downloads may experience delays based on network conditions. Extending the timeout ensures the test waits for the full image download."
    },
    {
      "input": "const serverConnection = connectToServer(); async function getServerStatus() { return await serverConnection.status(); } test('should get server status', async () => { const status = await getServerStatus(); expect(status).toBe('running'); });",
      "output": "Manage Resource: The server connection should be closed after the test to avoid resource contention."
    },
    {
      "input": "async function fetchPaymentData() { const response = await fetch('https://api.example.com/payment'); return await response.json(); } test('should fetch payment data within timeout', async () => { const payment = await fetchPaymentData(); expect(payment).toBeDefined(); });",
      "output": "Handle Timeout: Using AbortController to timeout payment data fetching."
    },
    {
      "input": "async function fetchOrders(service) { return await service.getOrders(); } test('should fetch orders', async () => { const service = new OrderService(); const orders = await fetchOrders(service); expect(orders.length).toBe(2); });",
      "output": "Add Mock: Using EventEmitter to simulate order fetching asynchronously."
    },
    {
      "input": "async function connectToService() { const service = await serviceManager.connect(); return service; } test('should connect to service', async () => { const service = await connectToService(); expect(service).toBeDefined(); });",
      "output": "Manage Resource: Connections to external services must be closed to prevent running out of available connections. Ensuring the connection is closed avoids resource leaks."
    },
    {
      "input": "test('should render notification after order completion', async () => { completeOrder(123); expect(document.querySelector('.notification').textContent).toBe('Order completed!'); });",
      "output": "Add/Adjust Wait: The notification message appears asynchronously after the order is processed. Adding a wait ensures the DOM is updated before the test assertion."
    },
    {
      "input": "test('should return transaction details', async () => { const transaction = await getTransaction(); expect(transaction).toEqual({ id: 10, amount: 200, status: 'completed' }); });",
      "output": "Widen Assertion: Using chai's deep.include for partial transaction matching."
    },
    {
      "input": "test('should add an item to wishlist', async () => { addToWishlist('item1'); const wishlist = await getWishlist(); expect(wishlist.items).toContain('item1'); });",
      "output": "Isolate State: The wishlist may retain previous data, causing flakiness. Resetting the wishlist ensures independence between tests."
    },
    {
      "input": "test('should acquire and release network resource', async () => { const resource = await acquireNetworkResource(); await resource.sendData('packet'); });",
      "output": "Manage Resource: Network resources should be released after use to avoid resource exhaustion or interference with other network operations."
    },
    {
      "input": "async function uploadFile() { return await fetch('https://api.example.com/upload', { method: 'POST', body: fileData }); } test('should upload file within time limit', async () => { const response = await uploadFile(); expect(response.ok).toBe(true); });",
      "output": "Manage Resource: Using AbortController to cancel file upload if timeout exceeded."
    },
    {
      "input": "async function copyS3Object(srcBucket, srcKey, destBucket, destKey) { const response = await s3.copyObject({ CopySource: `${srcBucket}/${srcKey}`, Bucket: destBucket, Key: destKey }).promise(); return response; } test('should copy S3 object', async () => { const result = await copyS3Object('source-bucket', 'file.txt', 'dest-bucket', 'copied.txt'); expect(result).toBeDefined(); });",
      "output": "Add Mock: Mocking the copyObject method for AWS S3."
    },
    {
      "input": "let notificationQueue = []; async function queueNotification(userId, message) { notificationQueue.push({ userId, message }); return notificationQueue; } test('should queue notification', async () => { const notifications = await queueNotification(101, 'New Video Uploaded'); expect(notifications.length).toBe(1); });",
      "output": "Isolate State: The `notificationQueue` array should be reset between tests to avoid state sharing."
    },
    {
      "input": "test('should score exactly 300 points for defeating a boss', async () => { const points = await getBossDefeatScore(); expect(points).toBe(300); });",
      "output": "Widen Assertion: The points awarded for defeating a boss may fluctuate slightly based on different factors in the game. Widening the range ensures the test remains stable despite these fluctuations."
    },
    {
      "input": "test('should retrieve shipping details within 2 seconds', async () => { const shipping = await fetchShippingDetails(); expect(shipping.success).toBe(true); }, 2000);",
      "output": "Handle Timeout: Fetching shipping details, especially for complex orders with multiple products, may exceed short timeouts. Extending the timeout ensures stability."
    },
    {
      "input": "test('should award exactly 1200 points for completing the dungeon', async () => { const points = await completeDungeon(); expect(points).toBe(1200); });",
      "output": "Widen Assertion: Dungeon runs may result in slightly varying points due to performance. Widening the acceptable point range ensures the test remains stable."
    },
    {
      "input": "test('should return exactly 200 messages', async () => { const messages = await fetchMessages(); expect(messages.length).toBe(200); });",
      "output": "Widen Assertion: The number of messages retrieved may vary. Widening the assertion range ensures the test remains stable even with minor variations."
    },
    {
      "input": "test('should fetch recent transactions from bank API', async () => { const transactions = await getBankTransactions(); expect(transactions.length).toBeGreaterThan(0); });",
      "output": "Handle Timeout: Bank API responses might take longer to process, causing timeouts. Increasing the timeout ensures the test waits for the response."
    },
    {
      "input": "let userLoggedIn = false; async function fetchTask() { userLoggedIn = true; } async function logout() { userLoggedIn = false; } test('should fetchTask and logout user', async () => { await fetchTask(); await logout(); expect(userLoggedIn).toBe(false); });",
      "output": "Isolate State: In this scenario, the test relies on a shared variable 'userLoggedIn' to track user login status. This shared state can lead to interference when multiple tests run concurrently, causing flakiness. By isolating the user state within each test, we ensure independence and prevent unexpected interactions."
    },
    {
      "input": "test('should reset session before processing payment', async () => { processPayment('order123'); const session = await fetchSessionData(); expect(session.orderId).toBe('order123'); });",
      "output": "Isolate State: Session data from previous tests may interfere with the current test. Resetting the session ensures isolated execution."
    },
    {
      "input": "test('should close socket connection after data exchange', async () => { const socket = await openSocket(); await sendData(socket, 'data'); expect(socket.isClosed()).toBe(true); });",
      "output": "Manage Resource: Socket connections left open can cause resource depletion. Ensuring they are closed after tests resolves this issue."
    },
    {
      "input": "test('should enable checkout button after cart update', async () => { updateCart(); expect(document.querySelector('#checkout').disabled).toBe(false); });",
      "output": "Add/Adjust Wait: Updating the cart is an asynchronous operation. Adding a wait ensures the test waits for the cart update to complete."
    },
    {
      "input": "test('should display search results after typing in search bar', async () => { typeInSearchBar('laptop'); expect(document.querySelectorAll('.search-result').length).toBe(5); });",
      "output": "Add/Adjust Wait: Search results may load asynchronously after typing. Adding a wait ensures that all results are displayed before asserting."
    },
    {
      "input": "async function fetchUserProfile() { let ready = false; setTimeout(() => { ready = true; }, 500); return ready; } test('should fetch user profile', async () => { const ready = await fetchUserProfile(); expect(ready).toBe(true); });",
      "output": "Add/Adjust Wait: The test ends before the user profile is fetched. Refactor the function to wait until the data is ready."
    },
    {
      "input": "test('should show error message after form submission', async () => { submitForm(); expect(document.querySelector('#error-msg').textContent).toBe('Submission failed'); });",
      "output": "Add/Adjust Wait: Using MutationObserver to wait for the error message DOM update."
    },
    {
      "input": "let fileDownloader; async function downloadFile(fileId) { fileDownloader = await FileDownloadService.download(fileId); return fileDownloader; } test('should download file', async () => { const download = await downloadFile('file123'); expect(download).toBeDefined(); });",
      "output": "Manage Resource: Ensure the file downloader is properly stopped and resources freed after each test."
    },
    {
      "input": "test('should clear search history before performing a new search', async () => { performSearch('item'); const history = await getSearchHistory(); expect(history).toContain('item'); });",
      "output": "Isolate State: Search history from previous tests might affect current searches. Clearing the history ensures isolated test conditions."
    },
    {
      "input": "async function upgradePlayerArmor(playerId) { return new Promise(resolve => setTimeout(() => resolve('Armor Upgraded'), 3000)); } test('should upgrade player armor', async () => { const result = await upgradePlayerArmor(101); expect(result).toBe('Armor Upgraded'); });",
      "output": "Add/Adjust Wait: Armor upgrades may take time due to server processing. Add more wait time for consistent results."
    },
    {
      "input": "test('should return exactly 100 points for the user', async () => { const points = await fetchUserPoints(); expect(points).toBe(100); });",
      "output": "Widen Assertion: Points can vary slightly based on recent activity. Widening the assertion to allow for a small range makes the test more resilient."
    },
    {
      "input": "let cart = { total: 0 }; async function updateCart(amount) { cart.total += amount; } test('should update cart total', async () => { await updateCart(50); expect(cart.total).toBe(50); });",
      "output": "Isolate State: Using test-specific modules to isolate cart total state."
    },
    {
      "input": "async function processOrders() { let totalOrders = 0; await fetchOrders().then(orders => { totalOrders = orders.length; }); return totalOrders; } test('should process orders count', async () => { const count = await processOrders(); expect(count).toBeGreaterThan(0); });",
      "output": "Isolate State: In this test, the totalOrders variable is shared across async operations, which can lead to race conditions and incorrect results. By isolating the state within the async flow, we ensure that each operation maintains its own consistent state, improving reliability and preventing interference between async tasks."
    },
    {
      "input": "let appErrors = []; async function logError(error) { appErrors.push(error); return appErrors; } test('should log app error', async () => { const result = await logError('Error1'); expect(result.length).toBe(1); });",
      "output": "Isolate State: Logged errors persist between tests, leading to state leakage. Reset the errors before each test."
    },
    {
      "input": "async function getLocationData() { const response = await fetch('https://api.mobileapp.com/location'); return await response.json(); } test('should fetch location data', async () => { const location = await getLocationData(); expect(location.city).toBe('San Francisco'); });",
      "output": "Add Mock: Mocking location data to simulate API responses without network dependency."
    },
    {
      "input": "test('should display patient check-in success message', async () => { checkInPatient(); expect(document.querySelector('.check-in-message').textContent).toBe('Check-in successful'); });",
      "output": "Add/Adjust Wait: The check-in confirmation may not appear immediately due to asynchronous processing. Adding a wait ensures the success message is rendered before assertion."
    },
    {
      "input": "let order = { id: 123, total: 100 }; async function fetchOrderDetails() { return await getOrderDetails(order); } test('should fetch order without modifying state', async () => { const orderDetails = await fetchOrderDetails(); expect(orderDetails.id).toBe(123); });",
      "output": "Isolate State: Freezing the order object to enforce immutability across tests."
    },
    {
      "input": "let wishlist = []; test('should add an item to the wishlist', async () => { wishlist = await addToWishlist('Item 1'); expect(wishlist.length).toBe(1); }); test('should clear the wishlist', async () => { wishlist = await clearWishlist(); expect(wishlist.length).toBe(0); });",
      "output": "Isolate State: Reset the wishlist between tests to avoid state contamination."
    },
    {
      "input": "async function fetchSettings(settingsService) { return await settingsService.getSettings(); } test('should fetch user settings', async () => { const settingsService = new SettingsService(); const settings = await fetchSettings(settingsService); expect(settings).toBeDefined(); });",
      "output": "Add Mock: Injecting mock settings service using dependency injection."
    },
    {
      "input": "async function getTaxEstimate(zipCode) { const response = await fetch(`/api/tax/estimate/${zipCode}`); return await response.json(); } test('should return exact tax estimate', async () => { const tax = await getTaxEstimate('90210'); expect(tax).toBe(7.25); });",
      "output": "Widen Assertion: Tax estimates can vary slightly depending on location and regulations. Adjust the assertion for flexibility."
    },
    {
      "input": "let apiClient = createApiClient(); async function fetchData() { return await apiClient.getData(); } test('should fetch data from API', async () => { const data = await fetchData(); expect(data).toBeDefined(); });",
      "output": "Isolate State: Reinitializing the API client for each test to ensure test-specific state."
    },
    {
      "input": "test('should fetch product reviews from server', async () => { const reviews = await fetchProductReviews(); expect(reviews.length).toBeGreaterThan(0); });",
      "output": "Handle Timeout: Fetching product reviews may take longer due to server load. Increasing the timeout ensures the test waits for the full response."
    },
    {
      "input": "test('should update button text after clicking', async () => { clickButton(); expect(document.querySelector('#button').textContent).toBe('Clicked'); });",
      "output": "Add/Adjust Wait: Using requestAnimationFrame to wait for DOM updates."
    },
    {
      "input": "let user = { loggedIn: false }; async function login() { user.loggedIn = true; localStorage.setItem('user', JSON.stringify(user)); } test('should log in user', async () => { await login(); expect(JSON.parse(localStorage.getItem('user')).loggedIn).toBe(true); });",
      "output": "Isolate State: Sharing user login state across tests can cause test failures. Resetting `localStorage` and isolating the state ensures clean test runs."
    },
    {
      "input": "async function fetchTimestamp() { return Date.now(); } test('should match exact fetched timestamp', async () => { const timestamp = await fetchTimestamp(); expect(timestamp).toBe(Date.now()); });",
      "output": "Widen Assertion: Exact matches of timestamps can cause flaky tests. Widening the assertion resolves the issue."
    },
    {
      "input": "async function getPaymentHistory() { const response = await fetch('/api/payments/history'); return await response.json(); } test('should fetch payment history', async () => { const history = await getPaymentHistory(); expect(history.length).toBe(10); });",
      "output": "Add Mock: Payment history can change frequently, leading to flakiness in tests. Mocking the API call ensures that a consistent set of data is returned each time."
    },
    {
      "input": "test('should close API connection after fetching user profile', async () => { const api = await openApiConnection(); await fetchUserProfile('user-001'); expect(api.isClosed()).toBe(true); });",
      "output": "Manage Resource: API connections should be closed after use to prevent resource leaks. Closing the connection ensures efficient resource management."
    },
    {
      "input": "async function fetchSettings(service) { return await service.getSettings(); } test('should fetch settings', async () => { const service = new SettingsService(); const settings = await fetchSettings(service); expect(settings.theme).toBe('dark'); });",
      "output": "Add Mock: Using EventEmitter to simulate async settings fetching."
    },
    {
      "input": "test('should verify email within 3 seconds', async () => { const result = await verifyEmail('user@example.com'); expect(result.verified).toBe(true); });",
      "output": "Handle Timeout: Verifying email can take longer than expected. Adding a timeout ensures the test fails if the operation takes too long."
    },
    {
      "input": "test('should highlight invalid fields after form submission', async () => { submitForm(); expect(document.querySelector('.error').style.display).toBe('block'); });",
      "output": "Add/Adjust Wait: Form submission triggers asynchronous validation, and the test checks too early for the error display. Adding a wait solves this."
    },
    {
      "input": "test('should show success message after data submission', async () => { submitData(); expect(document.querySelector('#success-message')).toBeDefined(); });",
      "output": "Add/Adjust Wait: Using async-retry to handle retrying data submission."
    },
    {
      "input": "test('should reset promo code state before applying new code', async () => { applyPromoCode('SAVE10'); const promo = await fetchAppliedPromoCode(); expect(promo).toBe('SAVE10'); });",
      "output": "Isolate State: Promo code states from previous tests may persist, leading to inconsistencies. Resetting the state ensures proper isolation."
    },
    {
      "input": "test('should fetch weather data within 3 seconds', async () => { const weather = await getWeatherData(); expect(weather).toBeDefined(); });",
      "output": "Handle Timeout: Using AbortController to handle timeouts in the weather data fetching."
    },
    {
      "input": "test('should show updated stock price after refresh', async () => { refreshStockPrice(); expect(document.querySelector('#price').textContent).toBe('$200'); });",
      "output": "Add/Adjust Wait: Stock prices update asynchronously. Adding a wait ensures the price is refreshed in the DOM before assertion."
    },
    {
      "input": "test('should return complete user order history', async () => { const history = await getOrderHistory(); expect(history).toEqual([{ orderId: 1, amount: 100, status: 'Delivered' }, { orderId: 2, amount: 200, status: 'Shipped' }]); });",
      "output": "Widen Assertion: Asserting only key fields like `orderId` and `status`, allowing flexibility in other properties."
    },
    {
      "input": "test('should fetch transaction history from banking API', async () => { const history = await getTransactionHistory(); expect(history.length).toBeGreaterThan(5); });",
      "output": "Handle Timeout: Transaction histories can be slow to load due to the volume of data. Extending the timeout ensures the test waits for the full response."
    },
    {
      "input": "let s3Client; async function initializeS3Client() { s3Client = await S3Client.init(); return s3Client; } test('should initialize S3 client', async () => { const client = await initializeS3Client(); expect(client).toBeDefined(); });",
      "output": "Manage Resource: Ensure S3 client resources are cleaned up after each test to avoid leaks in cloud resources."
    },
    {
      "input": "let dbTransaction; async function startTransaction() { dbTransaction = await Database.startTransaction(); return dbTransaction; } test('should start database transaction', async () => { const transaction = await startTransaction(); expect(transaction).toBeDefined(); });",
      "output": "Manage Resource: Ensure database transactions are properly rolled back or committed after each test."
    },
    {
      "input": "test('should show exactly 6 saved addresses', async () => { const addresses = await getSavedAddresses(); expect(addresses.length).toBe(6); });",
      "output": "Widen Assertion: The number of saved addresses can vary due to changes in user data. Widening the assertion ensures test stability."
    },
    {
      "input": "async function downloadImage() { const http = openHttpConnection(); return http.get('/image.png'); } test('should download image and close HTTP connection', async () => { const image = await downloadImage(); expect(image).toBeDefined(); });",
      "output": "Manage Resource: Using Promise.finally to ensure HTTP connection is closed."
    },
    {
      "input": "test('should display player rank after API call', async () => { loadPlayerRank('player-001'); expect(document.querySelector('#player-rank').textContent).toBe('1'); });",
      "output": "Add/Adjust Wait: Player rank might not load immediately due to network delays. Adding a wait ensures the rank is displayed before assertions."
    },
    {
      "input": "test('should receive invoice data from billing system', async () => { const invoice = await fetchInvoiceData(); expect(invoice.total).toBeGreaterThan(0); });",
      "output": "Handle Timeout: Billing systems may take longer to process and return data, especially during high-traffic periods. Extending the timeout ensures the test waits for a full response."
    },
    {
      "input": "test('should return exactly 30 items in cart', async () => { const cartItems = await getCartItems(); expect(cartItems.length).toBe(30); });",
      "output": "Widen Assertion: The number of cart items might vary slightly due to dynamic data. Widening the assertion ensures minor variations are handled."
    },
    {
      "input": "test('should return account details with correct balance', async () => { const account = await getAccountDetails(); expect(account.balance).toBe(5000); });",
      "output": "Widen Assertion: Using toMatchObject for partial matching of account details."
    },
    {
      "input": "async function connectToGameEventStream() { const socket = new WebSocket('wss://game-events.example.com'); return socket; } test('should establish WebSocket connection to the game event stream', async () => { const socket = await connectToGameEventStream(); expect(socket.readyState).toBe(1); });",
      "output": "Manage Resource: Game event streams that rely on WebSocket connections should be closed after use to prevent memory and resource leaks. Closing the WebSocket in a `finally` block ensures that it is terminated correctly."
    },
    {
      "input": "test('should connect to the service within 4 seconds', async () => { const connection = await connectToService(); expect(connection.status).toBe('connected'); });",
      "output": "Handle Timeout: Connecting to an external service may take too long. Adding a timeout ensures that the test doesn't hang indefinitely."
    },
    {
      "input": "test('should display search results after submitting query', async () => { submitSearch('laptop'); expect(document.querySelectorAll('.search-result').length).toBe(4); });",
      "output": "Add/Adjust Wait: Search results load asynchronously after submission. Adding a wait ensures that results are fully rendered before asserting."
    },
    {
      "input": "async function fetchInventoryWeight(itemId) { const response = await fetch(`/api/inventory/${itemId}/weight`); return await response.json(); } test('should return inventory weight', async () => { const weight = await fetchInventoryWeight('item123'); expect(weight).toBe(5); });",
      "output": "Widen Assertion: Weight data may be rounded or vary slightly due to packaging differences. Widening the assertion ensures more flexibility."
    },
    {
      "input": "async function getQuestCompletionTime(questId) { const response = await fetch(`/api/quest/${questId}/completionTime`); return await response.json(); } test('should return quest completion time', async () => { const time = await getQuestCompletionTime('quest123'); expect(time).toBe(300); });",
      "output": "Widen Assertion: Completion times may vary slightly due to server processing or latency. Widen the assertion to allow for this."
    },
    {
      "input": "async function processOrders() { const orders = await fetchOrders(); await updateInventory(orders); } test('should process orders and update inventory', async () => { await processOrders(); expect(inventory.updated).toBeTruthy(); });",
      "output": "Manage Resource: Async operations like fetching orders and updating inventory can consume system resources. Proper resource management is crucial to prevent resource leaks and ensure efficient utilization of resources."
    },
    {
      "input": "test('should process user engagement data within 5 seconds', async () => { const engagementData = await processUserEngagementData(); expect(engagementData.success).toBe(true); }, 5000);",
      "output": "Handle Timeout: Processing large user engagement datasets can take longer, especially when analyzing big data. Extending the timeout ensures the test accommodates the longer processing time."
    },
    {
      "input": "async function getPlayerMana(playerId) { const response = await fetch(`/api/player/${playerId}/mana`); return await response.json(); } test('should return player mana', async () => { const mana = await getPlayerMana(101); expect(mana).toBe(200); });",
      "output": "Widen Assertion: Mana values may vary slightly depending on gameplay. Widen the assertion to handle minor fluctuations."
    },
    {
      "input": "const fileHandle = openFile('log.txt'); async function readLogFile() { return await fileHandle.read(); } test('should read log file', async () => { const content = await readLogFile(); expect(content).toContain('Log started'); });",
      "output": "Manage Resource: Ensuring the file handle is closed after each test prevents file system resource exhaustion."
    },
    {
      "input": "test('should reset file storage before uploading file', async () => { uploadFile('newfile.txt'); const files = await getStoredFiles(); expect(files).toContain('newfile.txt'); });",
      "output": "Isolate State: The file storage may contain files from previous tests, leading to flaky behavior. Resetting the storage ensures a clean state for each test."
    },
    {
      "input": "test('should display server logs after server startup', async () => { startServer('srv-123'); expect(document.querySelector('#log-output').textContent).toContain('Server started'); });",
      "output": "Add/Adjust Wait: Server startup logs may take time to appear, especially in cloud environments. Adding a wait ensures the logs are available before asserting."
    },
    {
      "input": "async function fetchNotifications() { const response = await fetch('https://api.example.com/notifications'); return await response.json(); } test('should fetch notifications within acceptable time', async () => { const notifications = await fetchNotifications(); expect(notifications).toBeDefined(); });",
      "output": "Handle Timeout: Using AbortController to apply timeout to notifications fetch."
    },
    {
      "input": "async function processFiles() { const files = await readFiles(); const processedFiles = await process(files); await saveProcessedFiles(processedFiles); } test('should process files', async () => { await processFiles(); expect(true).toBe(true); });",
      "output": "Manage Resource: Ensuring proper resource cleanup is essential to prevent resource leaks and potential conflicts in async operations. Releasing resources like file handles after processing is crucial to maintain system stability and prevent issues related to resource exhaustion."
    },
    {
      "input": "let websocket; async function openWebSocket() { websocket = new WebSocket('wss://example.com'); return new Promise(resolve => { websocket.onopen = () => resolve('WebSocket open'); }); } test('should open WebSocket connection', async () => { const result = await openWebSocket(); expect(result).toBe('WebSocket open'); });",
      "output": "Manage Resource: WebSocket connections can remain open between tests, causing resource issues. Closing the connection after each test solves this."
    },
    {
      "input": "async function fetchOrderDetails(api, orderId) { return await api.getOrder(orderId); } test('should fetch order details', async () => { const api = new OrderApi(); const order = await fetchOrderDetails(api, 123); expect(order).toBeDefined(); });",
      "output": "Add Mock: Mocking the entire OrderApi module."
    },
    {
      "input": "test('should get shipping info from slow service', async () => { const shippingInfo = await fetchShippingInfo(); expect(shippingInfo.status).toBe('shipped'); });",
      "output": "Handle Timeout: The shipping service may respond slowly, causing flaky tests. Increasing the timeout allows the test to wait for the response."
    },
    {
      "input": "test('should load dashboard after login', async () => { login(); expect(document.querySelector('#dashboard').style.display).toBe('block'); });",
      "output": "Add/Adjust Wait: The dashboard loading is asynchronous, and the test might check before it's fully visible. Adding a wait ensures the test waits for the operation to complete."
    },
    {
      "input": "test('should display exactly 20 products', async () => { const products = await fetchProducts(); expect(products.length).toBe(20); });",
      "output": "Widen Assertion: Product listings can vary, so widening the range improves test stability."
    },
    {
      "input": "async function getWeather(service) { const weather = await service.fetchWeather(); return weather; } test('should fetch weather data', async () => { const service = new WeatherService(); const weather = await getWeather(service); expect(weather.temperature).toBe(75); });",
      "output": "Add Mock: Spying on the `fetchWeather` method to validate its call and mocking the weather data."
    },
    {
      "input": "async function fetchCurrencyRates() { const response = await fetch('https://api.forex.com/rates'); return await response.json(); } test('should fetch currency rates', async () => { const rates = await fetchCurrencyRates(); expect(rates.USD).toBeDefined(); });",
      "output": "Add Mock: Mocking currency rates API to stabilize test behavior."
    },
    {
      "input": "async function processFileData() { const fileData = await readFile('example.txt'); const processedData = await processData(fileData); return processedData; } test('should process file data correctly', async () => { const result = await processFileData(); expect(result).toEqual({ status: 'processed' }); });",
      "output": "Widen Assertion: The test currently expects the processed data to have an exact structure ({ status: 'processed' }), which may not always be consistent due to variations in file content or processing logic. By widening the assertion to check for essential properties or values instead of an exact match, the test can accommodate valid variations without compromising its core validation."
    },
    {
      "input": "test('should send email within 2 seconds', async () => { const result = await sendEmail(); expect(result.status).toBe('Sent'); });",
      "output": "Handle Timeout: Sending email may take longer depending on the email service and network conditions. Increasing the timeout ensures successful email sending."
    },
    {
      "input": "test('should update user profile after multiple async calls', async () => { let userId = await getUserID(); let userProfile = await getUserProfile(userId); let updatedProfile = await updateUserProfile(userProfile); expect(updatedProfile).toEqual({ name: 'John Doe', email: 'john.doe@example.com' }); });",
      "output": "Add/Adjust Wait: In this test, multiple async calls are made to fetch user ID, profile, and update the profile. The test may fail due to the timing of these calls and assertions. By adding appropriate waits, we can ensure that each async operation completes before proceeding with the next step, improving test reliability."
    },
    {
      "input": "let ftpClient = openFtpConnection(); async function uploadFile() { await ftpClient.upload('/path/to/file'); } test('should upload file and finalize FTP connection', async () => { await uploadFile(); expect(ftpClient.status).toBe('closed'); });",
      "output": "Manage Resource: Using finalize to ensure FTP connection cleanup after file upload."
    },
    {
      "input": "test('should close database connection after querying data', async () => { const connection = await openDbConnection(); await queryData(connection); expect(connection.isClosed()).toBe(true); });",
      "output": "Manage Resource: Database connections left open can exhaust system resources. Ensuring connections are closed after tests resolves this issue."
    },
    {
      "input": "test('should fetch promotional banners', async () => { const banners = await fetchPromotionalBanners(); expect(banners.length).toBeGreaterThan(0); });",
      "output": "Handle Timeout: Fetching promotional banners from external systems may take extra time. Extending the timeout ensures stable test execution."
    },
    {
      "input": "test('should show loading spinner while data is being fetched', async () => { fetchData(); expect(document.querySelector('.spinner').style.display).toBe('block'); });",
      "output": "Add/Adjust Wait: The spinner may not appear immediately due to asynchronous fetch operation. Adding a wait ensures the spinner is checked at the right time."
    },
    {
      "input": "test('should update user profile after multiple async operations', async () => { const userId = '123'; let profileUpdated = false; updateUserProfile(userId); fetchUserProfile(userId).then(profile => { if (profile) { profileUpdated = true; } }); expect(profileUpdated).toBe(true); });",
      "output": "Add/Adjust Wait: The test fails due to the asynchronous nature of 'fetchUserProfile' which may not complete before the 'expect' assertion is executed. Adding a wait mechanism to ensure that the 'profileUpdated' flag is checked after the async operation completes will improve test reliability."
    },
    {
      "input": "test('should show confirmation message after form submission', async () => { submitForm(); expect(document.querySelector('.confirmation-message').textContent).toBe('Form submitted successfully'); });",
      "output": "Add/Adjust Wait: The confirmation message appears asynchronously after the form is submitted. Adding a wait ensures that the message is displayed before making assertions."
    },
    {
      "input": "async function fetchOrderSummary() { const response = await fetch('https://api.example.com/orders/summary'); return await response.json(); } test('should fetch order summary', async () => { const summary = await fetchOrderSummary(); expect(summary.total).toBe(1000); });",
      "output": "Add Mock: Network-dependent tests like fetching order summaries can fail intermittently. Mocking the response ensures reliability."
    },
    {
      "input": "test('should validate user input and fetch data', async () => { const userInput = await getUserInput(); const isValid = validateInput(userInput); const data = await fetchData(isValid); expect(data.length).toBe(3); });",
      "output": "Widen Assertion: The test currently expects the fetched data to have exactly 3 items, which can be too strict and lead to flakiness if the data retrieval process is slightly delayed or returns a different number of items. By widening the assertion, we allow for variations in the data response, making the test more resilient to timing issues and ensuring it focuses on the data's content rather than the exact count."
    },
    {
      "input": "test('should display product recommendations after scrolling to the bottom of the page', async () => { scrollToBottom(); expect(document.querySelectorAll('.recommendation-item').length).toBe(4); });",
      "output": "Add/Adjust Wait: Product recommendations load asynchronously as the user scrolls. Adding a wait ensures all items are displayed before asserting the count."
    },
    {
      "input": "test('should update shipment tracking data after package scanned', async () => { await scanPackage('shipment456'); const trackingData = getShipmentTracking(); expect(trackingData.status).toBe('In Transit'); });",
      "output": "Isolate State: Shipment tracking data might persist between tests, causing flaky results. Resetting the state ensures tests are independent."
    },
    {
      "input": "test('should retrieve weather data for user location', async () => { const weather = await fetchWeatherData('New York'); expect(weather.temperature).toBeGreaterThan(0); });",
      "output": "Handle Timeout: Weather APIs might experience delays during high traffic or slow network conditions. Extending the timeout ensures stable and predictable test results."
    },
    {
      "input": "let cacheConnection; async function connectToCache() { cacheConnection = await CacheService.connect(); return cacheConnection; } test('should connect to cache', async () => { const cache = await connectToCache(); expect(cache).toBeDefined(); });",
      "output": "Manage Resource: Ensure cache connections are properly disconnected after each test to prevent resource leaks."
    },
    {
      "input": "async function getReport() { const report = { id: 123, generated: true }; return report; } test('should generate and clean up report after test', async () => { const report = await getReport(); expect(report.generated).toBe(true); });",
      "output": "Manage Resource: Using resource-pool for report lifecycle management."
    },
    {
      "input": "test('should upload large CSV file within 3 seconds', async () => { const result = await uploadCSV('data.csv'); expect(result.success).toBe(true); }, 3000);",
      "output": "Handle Timeout: Large CSV file uploads may exceed the original timeout. Extending the timeout ensures that the test passes successfully even with longer upload durations."
    },
    {
      "input": "async function fetchTrackingPixel(pixelId) { const response = await getPixelData(pixelId); return response; } test('should fetch tracking pixel data', async () => { const pixel = await fetchTrackingPixel('pixel789'); expect(pixel.loaded).toBe(true); });",
      "output": "Manage Resource: Tracking pixel data can lead to resource exhaustion if not cleaned up. Ensuring the pixel data is released after fetching prevents system overload."
    },
    {
      "input": "test('should return order with nested product details', async () => { const order = await getOrder(); expect(order).toEqual({ orderId: 101, product: { name: 'Laptop', price: 1200 } }); });",
      "output": "Widen Assertion: Using deep comparison for nested product details validation."
    },
    {
      "input": "test('should close web socket after receiving data', async () => { const socket = openWebSocket(); await receiveData(socket); expect(socket.isClosed()).toBe(true); });",
      "output": "Manage Resource: Failing to close web sockets can lead to resource exhaustion. Ensuring the socket is closed after the test resolves the issue."
    },
    {
      "input": "test('should receive user session token', async () => { const token = await getSessionToken(); expect(token).toBeDefined(); });",
      "output": "Handle Timeout: Session tokens may take longer to generate, depending on server load. Increasing the timeout ensures the test waits for the token."
    },
    {
      "input": "async function getStockQuote() { const response = await fetch('https://api.stockmarket.com/quote'); return await response.json(); } test('should fetch stock quote', async () => { const quote = await getStockQuote(); expect(quote.symbol).toBeDefined(); });",
      "output": "Add Mock: Stock data fluctuates, so mocking the API provides a stable test environment."
    },
    {
      "input": "test('should load dashboard data from slow service', async () => { const data = await loadDashboardData(); expect(data.summary).toBeDefined(); });",
      "output": "Handle Timeout: The dashboard data loading service may take longer than expected, so extending the timeout ensures that the test passes."
    },
    {
      "input": "let notifications = []; async function addNotification(message) { notifications.push(message); } test('should add a notification', async () => { await addNotification('New message'); expect(notifications.length).toBe(1); });",
      "output": "Isolate State: Notifications stored globally across tests can cause interference. Using React's `useContext` ensures each test handles its own isolated notifications."
    },
    {
      "input": "let score = 0; async function updateScore(points) { score += points; return score; } test('should update score', async () => { const totalScore = await updateScore(100); expect(totalScore).toBe(100); });",
      "output": "Isolate State: The `score` variable should be reset between tests to avoid incorrect test results."
    },
    {
      "input": "let bookmarks = []; async function addBookmark(bookmark) { bookmarks.push(bookmark); return bookmarks; } test('should add bookmark', async () => { const result = await addBookmark('page1'); expect(result.length).toBe(1); });",
      "output": "Isolate State: Bookmarks persist between tests, causing state leakage. Reset the bookmarks before each test."
    },
    {
      "input": "async function checkEveningHours() { const now = new Date(); if (now.getHours() >= 18) return 'It\\'s evening'; return 'Not evening yet'; } test('should notify for evening hours', async () => { const result = await checkEveningHours(); expect(result).toBeDefined(); });",
      "output": "Add Mock: Using Sinon.js to mock time for evening notifications."
    },
    {
      "input": "test('should show CI status after build completes', async () => { completeBuild(); expect(document.querySelector('#ci-status').textContent).toBe('Passed'); });",
      "output": "Add/Adjust Wait: CI statuses are updated asynchronously after builds complete. Adding a wait ensures the status is available before asserting."
    },
    {
      "input": "async function uploadFileToS3() { return new Promise(resolve => { setTimeout(() => resolve('Upload Complete'), 10000); }); } test('should upload file to S3', async () => { const result = await uploadFileToS3(); expect(result).toBe('Upload Complete'); });",
      "output": "Handle Timeout: Uploading large files to S3 may take longer than the default timeout. Extend the timeout to prevent flakiness."
    },
    {
      "input": "async function fetchUserData() { const data = await fetchData(); return data; } test('should validate user data properties', async () => { const userData = await fetchUserData(); expect(userData.name).toBe('John Doe'); expect(userData.age).toBe(30); });",
      "output": "Widen Assertion: User data properties like name and age can vary based on dynamic user profiles. To enhance test stability, widen the assertion to check for the presence and type of properties rather than specific values."
    },
    {
      "input": "test('should display game assets after loading', async () => { loadGameAssets('asset-001'); expect(document.querySelector('#asset-img').src).toBe('https://example.com/asset.png'); });",
      "output": "Add/Adjust Wait: Game assets may take time to load from external servers. Adding a wait ensures the assets are fully loaded before assertions."
    },
    {
      "input": "async function getStockPrice(symbol) { const response = await fetch(`/api/stocks/${symbol}`); return await response.json(); } test('should fetch stock price', async () => { const stock = await getStockPrice('AAPL'); expect(stock.price).toBe(150); });",
      "output": "Add Mock: External API calls for stock prices can be delayed or fail due to network issues. Mocking the API provides stable and reliable test results."
    },
    {
      "input": "test('should reset recent searches before performing a new search', async () => { searchForItem('laptop'); const results = await fetchSearchHistory(); expect(results.length).toBe(1); });",
      "output": "Isolate State: Previous search history might interfere with new tests. Resetting ensures clean state for testing."
    },
    {
      "input": "async function getStockPrices() { const response = await fetch('https://api.stockmarket.com/prices'); return await response.json(); } test('should get stock prices', async () => { const prices = await getStockPrices(); expect(prices.length).toBeGreaterThan(0); });",
      "output": "Add Mock: Stock market data can fluctuate, so mocking the API stabilizes the test."
    },
    {
      "input": "async function getBucketEncryption(bucket) { const response = await s3.getBucketEncryption({ Bucket: bucket }).promise(); return response.ServerSideEncryptionConfiguration; } test('should get bucket encryption configuration', async () => { const encryption = await getBucketEncryption('my-bucket'); expect(encryption.Rules.length).toBeGreaterThan(0); });",
      "output": "Add Mock: Mocking getBucketEncryption for S3."
    },
    {
      "input": "test('should update investment portfolio after transaction', async () => { await buyStock('AAPL', 10); const portfolio = getPortfolio(); expect(portfolio.stocks.length).toBeGreaterThan(0); });",
      "output": "Isolate State: Shared portfolio state between tests can cause interference and lead to flaky tests. Resetting the portfolio ensures each test runs independently."
    },
    {
      "input": "test('should display music tracks after API call', async () => { fetchMusicTracks(); expect(document.querySelectorAll('.track').length).toBe(10); });",
      "output": "Add/Adjust Wait: Music tracks may take time to load due to API delays. Adding a wait ensures the tracks are loaded before making assertions."
    },
    {
      "input": "async function loadUserSettings(userId) { const response = await fetch(`/api/users/${userId}/settings`); return await response.json(); } test('should load user settings', async () => { const settings = await loadUserSettings(201); expect(settings.language).toBe('en'); });",
      "output": "Add Mock: Mock the user settings API to isolate the test from external services."
    },
    {
      "input": "let websocket = openWebSocket(); async function sendMessage() { await websocket.send('Hello'); } test('should send message via WebSocket', async () => { await sendMessage(); expect(websocket.messages).toContain('Hello'); });",
      "output": "Manage Resource: Using deferred cleanup of the WebSocket connection to ensure proper closing of the socket after each test."
    },
    {
      "input": "test('should display location after fetching user location', async () => { fetchUserLocation(); expect(document.querySelector('#location').textContent).toBe('New York'); });",
      "output": "Add/Adjust Wait: Fetching user location is asynchronous in mobile apps, especially when using GPS or external services. Adding a wait ensures the location is displayed before assertions."
    },
    {
      "input": "test('should return exactly 5 open support tickets', async () => { const tickets = await getOpenTickets(); expect(tickets.length).toBe(5); });",
      "output": "Widen Assertion: The number of open support tickets may fluctuate. Widening the assertion ensures the test handles changes gracefully."
    },
    {
      "input": "test('should fetch vendor payments data', async () => { const payments = await fetchVendorPayments('vendor-001'); expect(payments.length).toBeGreaterThan(0); });",
      "output": "Handle Timeout: Vendor payment data retrieval may take longer due to network or processing delays in enterprise systems. Extending the timeout prevents flaky tests."
    },
    {
      "input": "async function getPrescription(patientId) { const response = await fetch(`https://api.healthcare.com/prescriptions/${patientId}`); return await response.json(); } test('should fetch prescriptions for patient 102', async () => { const prescriptions = await getPrescription(102); expect(prescriptions.length).toBeGreaterThan(0); });",
      "output": "Add Mock: Mocking external API call for fetching prescriptions to avoid flaky tests due to external dependencies."
    },
    {
      "input": "let globalList = []; async function addItem(item) { globalList.push(item); } test('should add item to list', async () => { await addItem('Item A'); expect(globalList.length).toBe(1); });",
      "output": "Isolate State: Shared lists across tests can cause flaky behavior. Isolating the list ensures that each test operates independently without interference."
    },
    {
      "input": "async function confirmDelivery(orderId) { return new Promise(resolve => setTimeout(() => resolve('Delivered'), 7000)); } test('should confirm delivery', async () => { const result = await confirmDelivery(123); expect(result).toBe('Delivered'); });",
      "output": "Handle Timeout: Delivery confirmations might be delayed due to third-party carriers. Increase the timeout for reliability."
    },
    {
      "input": "async function getShippingDetails() { const response = await fetch('/api/shipping'); return await response.json(); } test('should fetch shipping details within timeout', async () => { const shipping = await getShippingDetails(); expect(shipping).toBeDefined(); });",
      "output": "Handle Timeout: Using Bluebird promises with timeout for shipping details fetch."
    },
    {
      "input": "test('should open and close file stream for patient history', async () => { const file = await openFileStream('history.txt'); await file.write('data'); });",
      "output": "Manage Resource: File streams should be properly closed after use to prevent file locking and resource leaks."
    },
    {
      "input": "test('should close API connection after fetching data', async () => { const apiConnection = await openApiConnection(); await fetchData(apiConnection); expect(apiConnection.isClosed()).toBe(true); });",
      "output": "Manage Resource: Leaving API connections open can cause resource depletion. Ensuring they are closed after each test resolves this."
    },
    {
      "input": "async function restoreBackup() { return new Promise(resolve => { setTimeout(() => { resolve('Backup Restored'); }, 6000); }); } test('should restore backup', async () => { const result = await restoreBackup(); expect(result).toBe('Backup Restored'); });",
      "output": "Handle Timeout: Restoring backups can be slow and may exceed the default timeout. Increasing the timeout resolves the flaky behavior."
    },
    {
      "input": "let cacheConnection = openCacheConnection(); async function fetchCachedData() { return await cacheConnection.get('key'); } test('should fetch cached data', async () => { const data = await fetchCachedData(); expect(data).toBeDefined(); });",
      "output": "Manage Resource: The cache connection remains open after the test, potentially leading to resource exhaustion. Closing the connection resolves this issue."
    },
    {
      "input": "test('should update user profile after file upload and database update', async () => { const file = await uploadFile(); await updateDatabase(file); const userProfile = await getUserProfile(); expect(userProfile.name).toBe('John Doe'); });",
      "output": "Add/Adjust Wait: In this test, multiple async operations like file upload, database update, and fetching user profile data are happening sequentially. The test may fail due to timing issues where the user profile update is not reflected immediately after the database update. By adding appropriate waits, we ensure that each operation completes before proceeding, making the test more reliable."
    },
    {
      "input": "let smsClient; async function connectToSmsGateway() { smsClient = await SmsGateway.connect(); return smsClient; } test('should connect to SMS gateway', async () => { const client = await connectToSmsGateway(); expect(client).toBeDefined(); });",
      "output": "Manage Resource: SMS gateway connections should be closed after each test to avoid excessive resource usage."
    },
    {
      "input": "test('should disable submit button after submitting form', async () => { submitForm(); expect(document.querySelector('#submit').disabled).toBe(true); });",
      "output": "Add/Adjust Wait: Using an event listener to wait for the `formSubmitted` event before checking the button's state."
    }
  ]
}
